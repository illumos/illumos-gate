'\" te
.\" Copyright (c) 2000, 2001, 2002, 2003, 2004 by Martin C. Shepherd. All Rights Reserved.
.\" Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the
.\" "Software"), to deal in the Software without restriction, including
.\" without limitation the rights to use, copy, modify, merge, publish,
.\" distribute, and/or sell copies of the Software, and to permit persons
.\" to whom the Software is furnished to do so, provided that the above
.\" copyright notice(s) and this permission notice appear in all copies of
.\" the Software and that both the above copyright notice(s) and this
.\" permission notice appear in supporting documentation.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
.\" OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
.\" HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
.\" INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
.\" FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
.\" NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
.\" WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.\" Except as contained in this notice, the name of a copyright holder
.\" shall not be used in advertising or otherwise to promote the sale, use
.\" or other dealings in this Software without prior written authorization
.\" of the copyright holder.
.\" Portions Copyright (c) 2005, Sun Microsystems, Inc. All Rights Reserved.
.TH TECLA 5 "Sep 10, 2013"
.SH NAME
tecla, teclarc \- User interface provided by the tecla library.
.SH DESCRIPTION
.sp
.LP
This man page describes the command-line editing features that are available to
users of programs that read keyboard input via the tecla library. Users of the
\fBtcsh shell\fR will find the default key bindings very familiar. Users of the
\fBbash\fR shell will also find it quite familiar, but with a few minor
differences, most notably in how forward and backward searches through the list
of historical commands are performed. There are two major editing modes, one
with \fBemacs\fR-like key bindings and another with \fBvi\fR-like key bindings.
By default \fBemacs\fR mode is enabled, but \fBvi\fR(1) mode can alternatively
be selected via the user's configuration file. This file can also be used to
change the bindings of individual keys to suit the user's preferences. By
default, tab completion is provided. If the application hasn't reconfigured
this to complete other types of symbols, then tab completion completes file
names.
.SS "Key Sequence Notation"
.sp
.LP
In the rest of this man page, and also in all tecla configuration files, key
sequences are expressed as follows.
.sp
.ne 2
.na
\fB\fB^A\fR or \fBC-a\fR\fR
.ad
.RS 13n
This is a 'CONTROL-A', entered by pressing the CONTROL key at the same time as
the 'A' key.
.RE

.sp
.ne 2
.na
\fB\fB\E\fR or \fBM-\fR\fR
.ad
.RS 13n
In key sequences, both of these notations can be entered either by pressing the
ESCAPE key, then the following key, or by pressing the META key at the same
time as the following key. Thus the key sequence \fBM-p\fR can be typed in two
ways, by pressing the ESCAPE key, followed by pressing 'P', or by pressing the
META key at the same time as 'P'.
.RE

.sp
.ne 2
.na
\fBup\fR
.ad
.RS 13n
This refers to the up-arrow key.
.RE

.sp
.ne 2
.na
\fBdown\fR
.ad
.RS 13n
This refers to the down-arrow key.
.RE

.sp
.ne 2
.na
\fBleft\fR
.ad
.RS 13n
This refers to the left-arrow key.
.RE

.sp
.ne 2
.na
\fBright\fR
.ad
.RS 13n
This refers to the right-arrow key.
.RE

.sp
.ne 2
.na
\fBa\fR
.ad
.RS 13n
This is just a normal 'A' key.
.RE

.SS "The Tecla Configuration File"
.sp
.LP
By default, tecla looks for a file called \fB\&.teclarc\fR in your home
directory (ie. \fB~/.teclarc\fR). If it finds this file, it reads it,
interpreting each line as defining a new key binding or an editing
configuration option. Since the \fBemacs\fR key-bindings are installed by
default, if you want to use the non-default \fBvi\fR editing mode, the most
important item to go in this file is the following line:
.sp
.in +2
.nf
edit-mode vi
.fi
.in -2

.sp
.LP
This will re-configure the default bindings for \fBvi\fR-mode. The complete set
of arguments that this command accepts are:
.sp
.ne 2
.na
\fBvi\fR
.ad
.RS 9n
Install key bindings like those of the \fBvi\fR editor.
.RE

.sp
.ne 2
.na
\fBemacs\fR
.ad
.RS 9n
Install key bindings like those of the \fBemacs\fR editor. This is the default.
.RE

.sp
.ne 2
.na
\fBnone\fR
.ad
.RS 9n
Use just the native line editing facilities provided by the terminal driver.
.RE

.sp
.LP
To prevent the terminal bell from being rung, such as when an unrecognized
control-sequence is typed, place the following line in the configuration file:
.sp
.in +2
.nf
nobeep
.fi
.in -2

.sp
.LP
An example of a key binding line in the configuration file is the following.
.sp
.in +2
.nf
bind M-[2~ insert-mode
.fi
.in -2

.sp
.LP
On many keyboards, the above key sequence is generated when one presses the
insert key, so with this key binding, one can toggle between the
\fBemacs\fR-mode insert and overwrite modes by hitting one key. One could also
do it by typing out the above sequence of characters one by one. As explained
above, the \fBM-\fR part of this sequence can be typed either by pressing the
ESCAPE key before the following key, or by pressing the META key at the same
time as the following key. Thus if you had set the above key binding, and the
insert key on your keyboard didn't generate the above key sequence, you could
still type it in either of the following 2 ways.
.RS +4
.TP
1.
Hit the ESCAPE key momentarily, then press '[', then '2', then finally '~'.
.RE
.RS +4
.TP
2.
Press the META key at the same time as pressing the '[' key, then press '2',
then '~'.
.RE
.sp
.LP
If you set a key binding for a key sequence that is already bound to a
function, the new binding overrides the old one. If in the new binding you omit
the name of the new function to bind to the key sequence, the original binding
becomes undefined.
.sp
.LP
Starting with versions of \fBlibtecla\fR later than 1.3.3 it is now possible to
bind key sequences that begin with a printable character. Previously key
sequences were required to start with a CONTROL or META character.
.sp
.LP
Note that the special keywords "up", "down", "left", and "right" refer to the
arrow keys, and are thus not treated as key sequences. So, for example, to
rebind the up and down arrow keys to use the history search mechanism instead
of the simple history recall method, you could place the following in your
configuration file:
.sp
.in +2
.nf
bind up history-search-backwards
bind down history-search-backwards
.fi
.in -2

.sp
.LP
To unbind an existing binding, you can do this with the bind command by
omitting to name any action to rebind the key sequence to. For example, by not
specifying an action function, the following command unbinds the default
beginning-of-line action from the \fB^A\fR key sequence:
.sp
.in +2
.nf
bind ^A
.fi
.in -2

.sp
.LP
If you create a \fB~/.teclarc\fR configuration file, but it appears to have no
effect on the program, check the documentation of the program to see if the
author chose a different name for this file.
.SS "Filename and Tilde Completion"
.sp
.LP
With the default key bindings, pressing the TAB key (aka. \fB^I\fR) results in
tecla attempting to complete the incomplete file name that precedes the cursor.
Tecla searches backwards from the cursor, looking for the start of the file
name, stopping when it hits either a space or the start of the line. If more
than one file has the specified prefix, then tecla completes the file name up
to the point at which the ambiguous matches start to differ, then lists the
possible matches.
.sp
.LP
In addition to literally written file names, tecla can complete files that
start with \fB~/\fR and \fB~user/\fR expressions and that contain \fB$envvar\fR
expressions. In particular, if you hit TAB within an incomplete \fB~user\fR,
expression, tecla will attempt to complete the username, listing any ambiguous
matches.
.sp
.LP
The completion binding is implemented using the \fBcpl_complete_word()\fR
function, which is also available separately to users of this library. See the
\fBcpl_complete_word\fR(3TECLA) man page for more details.
.SS "Filename Expansion"
.sp
.LP
With the default key bindings, pressing \fB^X*\fR causes tecla to expand the
file name that precedes the cursor, replacing \fB~/\fR and \fB~user/\fR
expressions with the corresponding home directories, and replacing
\fB$envvar\fR expressions with the value of the specified environment variable,
then if there are any wildcards, replacing the so far expanded file name with a
space-separated list of the files which match the wild cards.
.sp
.LP
The expansion binding is implemented using the \fBef_expand_file()\fR function.
See the \fBef_expand_file\fR(3TECLA) man page for more details.
.SS "Recalling Previously Typed Lines"
.sp
.LP
Every time that a new line is entered by the user, it is appended to a list of
historical input lines maintained within the \fBGetLine\fR resource object. You
can traverse up and down this list using the up and down arrow keys.
Alternatively, you can do the same with the \fB^P\fR, and \fB^N\fR keys, and in
\fBvi\fR command mode you can alternatively use the k and j characters. Thus
pressing up-arrow once, replaces the current input line with the previously
entered line. Pressing up-arrow again, replaces this with the line that was
entered before it, etc.. Having gone back one or more lines into the history
list, one can return to newer lines by pressing down-arrow one or more times.
If you do this sufficient times, you will return to the original line that you
were entering when you first hit up-arrow.
.sp
.LP
Note that in \fBvi\fR mode, all of the history recall functions switch the
library into command mode.
.sp
.LP
In \fBemacs\fR mode the \fBM-p\fR and \fBM-n\fR keys work just like the
\fB^P\fR and \fB^N\fR keys, except that they skip all but those historical
lines which share the prefix that precedes the cursor. In \fBvi\fR command mode
the upper case 'K' and 'J' characters do the same thing, except that the string
that they search for includes the character under the cursor as well as what
precedes it.
.sp
.LP
Thus for example, suppose that you were in \fBemacs\fR mode, and you had just
entered the following list of commands in the order shown:
.sp
.in +2
.nf
ls ~/tecla/
cd ~/tecla
ls -l getline.c
\fBemacs\fR ~/tecla/getline.c
.fi
.in -2

.sp
.LP
If you next typed:
.sp
.in +2
.nf
ls
.fi
.in -2

.sp
.LP
and then hit \fBM-p\fR, then rather than returning the previously typed
\fBemacs\fR line, which doesn't start with "ls", tecla would recall the "ls -l
getline.c" line. Pressing \fBM-p\fR again would recall the "ls ~/tecla/" line.
.sp
.LP
Note that if the string that you are searching for, contains any of the special
characters, *, ?, or '[', then it is interpretted as a pattern to be matched.
Thus, cotinuing with the above example, after typing in the list of commands
shown, if you then typed:
.sp
.in +2
.nf
*tecla*
.fi
.in -2

.sp
.LP
and hit \fBM-p\fR, then the "\fBemacs\fR ~/tecla/getline.c" line would be
recalled first, since it contains the word tecla somewhere in the line,
Similarly, hitting \fBM-p\fR again, would recall the "ls ~/tecla/" line, and
hitting it once more would recall the "ls ~/tecla/" line. The pattern syntax is
the same as that described for file name expansion, in the
\fBef_expand_file\fR(3TECLA).
.SS "History Files"
.sp
.LP
Authors of programs that use the tecla library have the option of saving
historical command-lines in a file before exiting, and subsequently reading
them back in from this file when the program is next started. There is no
standard name for this file, since it makes sense for each application to use
its own history file, so that commands from different applications don't get
mixed up.
.SS "International Character Sets"
.sp
.LP
Since \fBlibtecla\fR version 1.4.0, tecla has been 8-bit clean. This means that
all 8-bit characters that are printable in the user's current locale are now
displayed verbatim and included in the returned input line. Assuming that the
calling program correctly contains a call like the following,
.sp
.in +2
.nf
setlocale(LC_CTYPE, "");
.fi
.in -2

.sp
.LP
then the current locale is determined by the first of the environment variables
\fBLC_CTYPE\fR, \fBLC_ALL\fR, and \fBLANG\fR, that is found to contain a valid
locale name. If none of these variables are defined, or the program neglects to
call \fBsetlocale\fR, then the default C locale is used, which is US 7-bit
ASCII. On most unix-like platforms, you can get a list of valid locales by
typing the command:
.sp
.in +2
.nf
locale -a
.fi
.in -2

.sp
.LP
at the shell prompt.
.SS "Meta Keys and Locales"
.sp
.LP
Beware that in most locales other than the default C locale, META characters
become printable, and they are then no longer considered to match \fBM-c\fR
style key bindings. This allows international characters to be entered with the
compose key without unexpectedly triggering META key bindings. You can still
invoke META bindings, since there are actually two ways to do this. For example
the binding \fBM-c\fR can also be invoked by pressing the ESCAPE key
momentarily, then pressing the c key, and this will work regardless of locale.
Moreover, many modern terminal emulators, such as gnome's gnome-terminal's and
KDE's konsole terminals, already generate escape pairs like this when you use
the META key, rather than a real meta character, and other emulators usually
have a way to request this behavior, so you can continue to use the META key on
most systems.
.sp
.LP
For example, although xterm terminal emulators generate real 8-bit meta
characters by default when you use the META key, they can be configured to
output the equivalent escape pair by setting their \fBEightBitInput\fR X
resource to False. You can either do this by placing a line like the following
in your \fB~/.Xdefaults\fR file,
.sp
.in +2
.nf
XTerm*EightBitInput: False
.fi
.in -2

.sp
.LP
or by starting an \fBxterm\fR with an \fB-xrm\fR \&'*EightBitInput: False'
command-line argument. In recent versions of xterm you can toggle this feature
on and off with the 'Meta Sends Escape' option in the menu that is displayed
when you press the left mouse button and the CONTROL key within an xterm
window. In CDE, dtterms can be similarly coerced to generate escape pairs in
place of meta characters, by setting the \fBDtterm*KshMode\fR resource to True.
.SS "Entering International Characters"
.sp
.LP
If you don't have a keyboard that generates all of the international characters
that you need, there is usually a compose key that will allow you to enter
special characters, or a way to create one. For example, under X windows on
unix-like systems, if your keyboard doesn't have a compose key, you can
designate a redundant key to serve this purpose with the xmodmap command. For
example, on many PC keyboards there is a microsoft-windows key, which is
otherwise useless under Linux. On a laptop, for example, the \fBxev\fR program
might report that pressing this key generates keycode 115. To turn this key
into a COMPOSE  key, do the following:
.sp
.in +2
.nf
xmodmap -e 'keycode 115 = Multi_key'
.fi
.in -2

.sp
.LP
Type this key followed by a " character to enter an 'I' with a umlaut over it.
.SS "The Available Key Binding Functions"
.sp
.LP
The following is a list of the editing functions provided by the tecla library.
The names in the leftmost column of the list can be used in configuration files
to specify which function a given key or combination of keys should invoke.
They are also used in the next two sections to list the default key bindings in
\fBemacs\fR and \fBvi\fR modes.
.sp
.ne 2
.na
\fBuser-interrupt\fR
.ad
.RS 30n
Send a SIGINT signal to the parent process.
.RE

.sp
.ne 2
.na
\fBsuspend\fR
.ad
.RS 30n
Suspend the parent process.
.RE

.sp
.ne 2
.na
\fBstop-output\fR
.ad
.RS 30n
Pause terminal output.
.RE

.sp
.ne 2
.na
\fBstart-output\fR
.ad
.RS 30n
Resume paused terminal output.
.RE

.sp
.ne 2
.na
\fBliteral-next\fR
.ad
.RS 30n
Arrange for the next character to be treated as a normal character. This allows
control characters to be entered.
.RE

.sp
.ne 2
.na
\fBcursor-right\fR
.ad
.RS 30n
Move the cursor one character right.
.RE

.sp
.ne 2
.na
\fBcursor-left\fR
.ad
.RS 30n
Move the cursor one character left.
.RE

.sp
.ne 2
.na
\fBinsert-mode\fR
.ad
.RS 30n
Toggle between insert mode and overwrite mode.
.RE

.sp
.ne 2
.na
\fBbeginning-of-line\fR
.ad
.RS 30n
Move the cursor to the beginning of the line.
.RE

.sp
.ne 2
.na
\fBend-of-line\fR
.ad
.RS 30n
Move the cursor to the end of the line.
.RE

.sp
.ne 2
.na
\fBdelete-line\fR
.ad
.RS 30n
Delete the contents of the current line.
.RE

.sp
.ne 2
.na
\fBkill-line\fR
.ad
.RS 30n
Delete everything that follows the cursor.
.RE

.sp
.ne 2
.na
\fBbackward-kill-line\fR
.ad
.RS 30n
Delete all characters between the cursor and the start of the line.
.RE

.sp
.ne 2
.na
\fBforward-word\fR
.ad
.RS 30n
Move to the end of the word which follows the cursor.
.RE

.sp
.ne 2
.na
\fBforward-to-word\fR
.ad
.RS 30n
Move the cursor to the start of the word that follows the cursor.
.RE

.sp
.ne 2
.na
\fBbackward-word\fR
.ad
.RS 30n
Move to the start of the word which precedes the cursor.
.RE

.sp
.ne 2
.na
\fBgoto-column\fR
.ad
.RS 30n
Move the cursor to the 1-relative column in the line specified by any preceding
digit-argument sequences (see Entering Repeat Counts below).
.RE

.sp
.ne 2
.na
\fBfind-parenthesis\fR
.ad
.RS 30n
If the cursor is currently over a parenthesis character, move it to the
matching parenthesis character. If not over a parenthesis character move right
to the next close parenthesis.
.RE

.sp
.ne 2
.na
\fBforward-delete-char\fR
.ad
.RS 30n
Delete the character under the cursor.
.RE

.sp
.ne 2
.na
\fBbackward-delete-char\fR
.ad
.RS 30n
Delete the character which precedes the cursor.
.RE

.sp
.ne 2
.na
\fBlist-or-eof\fR
.ad
.RS 30n
This is intended for binding to \fB^D\fR. When invoked when the cursor is
within the line it displays all possible completions then redisplays the line
unchanged. When invoked on an empty line, it signals end-of-input (EOF) to the
caller of \fBgl_get_line()\fR.
.RE

.sp
.ne 2
.na
\fBdel-char-or-list-or-eof\fR
.ad
.RS 30n
This is intended for binding to \fB^D\fR. When invoked when the cursor is
within the line it invokes forward-delete-char. When invoked at the end of the
line it displays all possible completions then redisplays the line unchanged.
When invoked on an empty line, it signals end-of-input (EOF) to the caller of
\fBgl_get_line()\fR.
.RE

.sp
.ne 2
.na
\fBforward-delete-word\fR
.ad
.RS 30n
Delete the word which follows the cursor.
.RE

.sp
.ne 2
.na
\fBbackward-delete-word\fR
.ad
.RS 30n
Delete the word which precedes the cursor.
.RE

.sp
.ne 2
.na
\fBupcase-word\fR
.ad
.RS 30n
Convert all of the characters of the word which follows the cursor, to upper
case.
.RE

.sp
.ne 2
.na
\fBdowncase-word\fR
.ad
.RS 30n
Convert all of the characters of the word which follows the cursor, to lower
case.
.RE

.sp
.ne 2
.na
\fBcapitalize-word\fR
.ad
.RS 30n
Capitalize the word which follows the cursor.
.RE

.sp
.ne 2
.na
\fBchange-case\fR
.ad
.RS 30n
If the next character is upper case, toggle it to lower case and vice versa.
.RE

.sp
.ne 2
.na
\fBredisplay\fR
.ad
.RS 30n
Redisplay the line.
.RE

.sp
.ne 2
.na
\fBclear-screen\fR
.ad
.RS 30n
Clear the terminal, then redisplay the current line.
.RE

.sp
.ne 2
.na
\fBtranspose-chars\fR
.ad
.RS 30n
Swap the character under the cursor with the character just before the cursor.
.RE

.sp
.ne 2
.na
\fBset-mark\fR
.ad
.RS 30n
Set a mark at the position of the cursor.
.RE

.sp
.ne 2
.na
\fBexchange-point-and-mark\fR
.ad
.RS 30n
Move the cursor to the last mark that was set, and move the mark to where the
cursor used to be.
.RE

.sp
.ne 2
.na
\fBkill-region\fR
.ad
.RS 30n
Delete the characters that lie between the last mark that was set, and the
cursor.
.RE

.sp
.ne 2
.na
\fBcopy-region-as-kill\fR
.ad
.RS 30n
Copy the text between the mark and the cursor to the cut buffer, without
deleting the original text.
.RE

.sp
.ne 2
.na
\fByank\fR
.ad
.RS 30n
Insert the text that was last deleted, just before the current position of the
cursor.
.RE

.sp
.ne 2
.na
\fBappend-yank\fR
.ad
.RS 30n
Paste the current contents of the cut buffer, after the cursor.
.RE

.sp
.ne 2
.na
\fBup-history\fR
.ad
.RS 30n
Recall the next oldest line that was entered. Note that in \fBvi\fR mode you
are left in command mode.
.RE

.sp
.ne 2
.na
\fBdown-history\fR
.ad
.RS 30n
Recall the next most recent line that was entered. If no history recall session
is currently active, the next line from a previous recall session is recalled.
Note that in vi mode you are left in command mode.
.RE

.sp
.ne 2
.na
\fBhistory-search-backward\fR
.ad
.RS 30n
Recall the next oldest line who's prefix matches the string which currently
precedes the cursor (in \fBvi\fR command-mode the character under the cursor is
also included in the search string). Note that in \fBvi\fR mode you are left in
command mode.
.RE

.sp
.ne 2
.na
\fBhistory-search-forward\fR
.ad
.RS 30n
Recall the next newest line who's prefix matches the string which currently
precedes the cursor (in \fBvi\fR command-mode the character under the cursor is
also included in the search string). Note that in \fBvi\fR mode you are left in
command mode.
.RE

.sp
.ne 2
.na
\fBhistory-re-search-backward\fR
.ad
.RS 30n
Recall the next oldest line who's prefix matches that established by the last
invocation of either history-search-forward or history-search-backward.
.RE

.sp
.ne 2
.na
\fBhistory-re-search-forward\fR
.ad
.RS 30n
Recall the next newest line who's prefix matches that established by the last
invocation of either history-search-forward or history-search-backward.
.RE

.sp
.ne 2
.na
\fBcomplete-word\fR
.ad
.RS 30n
Attempt to complete the incomplete word which precedes the cursor. Unless the
host program has customized word completion, file name completion is attempted.
In \fBvi\fR commmand mode the character under the cursor is also included in
the word being completed, and you are left in \fBvi\fR insert mode.
.RE

.sp
.ne 2
.na
\fBexpand-filename\fR
.ad
.RS 30n
Within the command line, expand wild cards, tilde expressions and dollar
expressions in the file name which immediately precedes the cursor. In \fBvi\fR
commmand mode the character under the cursor is also included in the file name
being expanded, and you are left in \fBvi\fR insert mode.
.RE

.sp
.ne 2
.na
\fBlist-glob\fR
.ad
.RS 30n
List any file names which match the wild-card, tilde and dollar expressions in
the file name which immediately precedes the cursor, then redraw the input line
unchanged.
.RE

.sp
.ne 2
.na
\fBlist-history\fR
.ad
.RS 30n
Display the contents of the history list for the current history group. If a
repeat count of \fB> 1\fR is specified, only that many of the most recent lines
are displayed. See the Entering Repeat Counts section.
.RE

.sp
.ne 2
.na
\fBread-from-file\fR
.ad
.RS 30n
Temporarily switch to reading input from the file who's name precedes the
cursor.
.RE

.sp
.ne 2
.na
\fBread-init-files\fR
.ad
.RS 30n
Re-read \fBteclarc\fR configuration files.
.RE

.sp
.ne 2
.na
\fBbeginning-of-history\fR
.ad
.RS 30n
Move to the oldest line in the history list. Note that in \fBvi\fR mode you are
left in command mode.
.RE

.sp
.ne 2
.na
\fBend-of-history\fR
.ad
.RS 30n
Move to the newest line in the history list (ie. the current line). Note that
in \fBvi\fR mode this leaves you in command mode.
.RE

.sp
.ne 2
.na
\fBdigit-argument\fR
.ad
.RS 30n
Enter a repeat count for the next key binding function. For details, see the
Entering Repeat Counts section.
.RE

.sp
.ne 2
.na
\fBnewline\fR
.ad
.RS 30n
Terminate and return the current contents of the line, after appending a
newline character. The newline character is normally '\en', but will be the
first character of the key sequence that invoked the newline action, if this
happens to be a printable character. If the action was invoked by the '\n'
newline character or the '\er' carriage return character, the line is appended
to the history buffer.
.RE

.sp
.ne 2
.na
\fBrepeat-history\fR
.ad
.RS 30n
Return the line that is being edited, then arrange for the next most recent
entry in the history buffer to be recalled when tecla is next called.
Repeatedly invoking this action causes successive historical input lines to be
re-executed. Note that this action is equivalent to the 'Operate' action in
ksh.
.RE

.sp
.ne 2
.na
\fBring-bell\fR
.ad
.RS 30n
Ring the terminal bell, unless the bell has been silenced via the nobeep
configuration option (see The Tecla Configuration File section).
.RE

.sp
.ne 2
.na
\fBforward-copy-char\fR
.ad
.RS 30n
Copy the next character into the cut buffer (NB. use repeat counts to copy more
than one).
.RE

.sp
.ne 2
.na
\fBbackward-copy-char\fR
.ad
.RS 30n
Copy the previous character into the cut buffer.
.RE

.sp
.ne 2
.na
\fBforward-copy-word\fR
.ad
.RS 30n
Copy the next word into the cut buffer.
.RE

.sp
.ne 2
.na
\fBbackward-copy-word\fR
.ad
.RS 30n
Copy the previous word into the cut buffer.
.RE

.sp
.ne 2
.na
\fBforward-find-char\fR
.ad
.RS 30n
Move the cursor to the next occurrence of the next character that you type.
.RE

.sp
.ne 2
.na
\fBbackward-find-char\fR
.ad
.RS 30n
Move the cursor to the last occurrence of the next character that you type.
.RE

.sp
.ne 2
.na
\fBforward-to-char\fR
.ad
.RS 30n
Move the cursor to the character just before the next occurrence of the next
character that the user types.
.RE

.sp
.ne 2
.na
\fBbackward-to-char\fR
.ad
.RS 30n
Move the cursor to the character just after the last occurrence before the
cursor of the next character that the user types.
.RE

.sp
.ne 2
.na
\fBrepeat-find-char\fR
.ad
.RS 30n
Repeat the last backward-find-char, forward-find-char, backward-to-char or
forward-to-char.
.RE

.sp
.ne 2
.na
\fBinvert-refind-char\fR
.ad
.RS 30n
Repeat the last backward-find-char, forward-find-char, backward-to-char, or
forward-to-char in the opposite direction.
.RE

.sp
.ne 2
.na
\fBdelete-to-column\fR
.ad
.RS 30n
Delete the characters from the cursor up to the column that is specified by the
repeat count.
.RE

.sp
.ne 2
.na
\fBdelete-to-parenthesis\fR
.ad
.RS 30n
Delete the characters from the cursor up to and including the matching
parenthesis, or next close parenthesis.
.RE

.sp
.ne 2
.na
\fBforward-delete-find\fR
.ad
.RS 30n
Delete the characters from the cursor up to and including the following
occurence of the next character typed.
.RE

.sp
.ne 2
.na
\fBbackward-delete-find\fR
.ad
.RS 30n
Delete the characters from the cursor up to and including the preceding
occurence of the next character typed.
.RE

.sp
.ne 2
.na
\fBforward-delete-to\fR
.ad
.RS 30n
Delete the characters from the cursor up to, but not including, the following
occurence of the next character typed.
.RE

.sp
.ne 2
.na
\fBbackward-delete-to\fR
.ad
.RS 30n
Delete the characters from the cursor up to, but not including, the preceding
occurence of the next character typed.
.RE

.sp
.ne 2
.na
\fBdelete-refind\fR
.ad
.RS 30n
Repeat the last *-delete-find or *-delete-to action.
.RE

.sp
.ne 2
.na
\fBdelete-invert-refind\fR
.ad
.RS 30n
Repeat the last *-delete-find or *-delete-to action, in the opposite direction.
.RE

.sp
.ne 2
.na
\fBcopy-to-column\fR
.ad
.RS 30n
Copy the characters from the cursor up to the column that is specified by the
repeat count, into the cut buffer.
.RE

.sp
.ne 2
.na
\fBcopy-to-parenthesis\fR
.ad
.RS 30n
Copy the characters from the cursor up to and including the matching
parenthesis, or next close parenthesis, into the cut buffer.
.RE

.sp
.ne 2
.na
\fBforward-copy-find\fR
.ad
.RS 30n
Copy the characters from the cursor up to and including the following occurence
of the next character typed, into the cut buffer.
.RE

.sp
.ne 2
.na
\fBbackward-copy-find\fR
.ad
.RS 30n
Copy the characters from the cursor up to and including the preceding occurence
of the next character typed, into the cut buffer.
.RE

.sp
.ne 2
.na
\fBforward-copy-to\fR
.ad
.RS 30n
Copy the characters from the cursor up to, but not including, the following
occurence of the next character typed, into the cut buffer.
.RE

.sp
.ne 2
.na
\fBbackward-copy-to\fR
.ad
.RS 30n
Copy the characters from the cursor up to, but not including, the preceding
occurence of the next character typed, into the cut buffer.
.RE

.sp
.ne 2
.na
\fBcopy-refind\fR
.ad
.RS 30n
Repeat the last *-copy-find or *-copy-to action.
.RE

.sp
.ne 2
.na
\fBcopy-invert-refind\fR
.ad
.RS 30n
Repeat the last *-copy-find or *-copy-to action, in the opposite direction.
.RE

.sp
.ne 2
.na
\fBvi-mode\fR
.ad
.RS 30n
Switch to \fBvi\fR mode from emacs mode.
.RE

.sp
.ne 2
.na
\fBemacs-mode\fR
.ad
.RS 30n
Switch to \fBemacs\fR mode from \fBvi\fR mode.
.RE

.sp
.ne 2
.na
\fBvi-insert\fR
.ad
.RS 30n
From \fBvi\fR command mode, switch to insert mode.
.RE

.sp
.ne 2
.na
\fBvi-overwrite\fR
.ad
.RS 30n
From \fBvi\fR command mode, switch to overwrite mode.
.RE

.sp
.ne 2
.na
\fBvi-insert-at-bol\fR
.ad
.RS 30n
From \fBvi\fR command mode, move the cursor to the start of the line and switch
to insert mode.
.RE

.sp
.ne 2
.na
\fBvi-append-at-eol\fR
.ad
.RS 30n
From \fBvi\fR command mode, move the cursor to the end of the line and switch
to append mode.
.RE

.sp
.ne 2
.na
\fBvi-append\fR
.ad
.RS 30n
From \fBvi\fR command mode, move the cursor one position right, and switch to
insert mode.
.RE

.sp
.ne 2
.na
\fBvi-replace-char\fR
.ad
.RS 30n
From \fBvi\fR command mode, replace the character under the cursor with the
next character entered.
.RE

.sp
.ne 2
.na
\fBvi-forward-change-char\fR
.ad
.RS 30n
From \fBvi\fR command mode, delete the next character then enter insert mode.
.RE

.sp
.ne 2
.na
\fBvi-backward-change-char\fR
.ad
.RS 30n
From vi command mode, delete the preceding character then enter insert mode.
.RE

.sp
.ne 2
.na
\fBvi-forward-change-word\fR
.ad
.RS 30n
From \fBvi\fR command mode, delete the next word then enter insert mode.
.RE

.sp
.ne 2
.na
\fBvi-backward-change-word\fR
.ad
.RS 30n
From vi command mode, delete the preceding word then enter insert mode.
.RE

.sp
.ne 2
.na
\fBvi-change-rest-of-line\fR
.ad
.RS 30n
From \fBvi\fR command mode, delete from the cursor to the end of the line, then
enter insert mode.
.RE

.sp
.ne 2
.na
\fBvi-change-line\fR
.ad
.RS 30n
From \fBvi\fR command mode, delete the current line, then enter insert mode.
.RE

.sp
.ne 2
.na
\fBvi-change-to-bol\fR
.ad
.RS 30n
From \fBvi\fR command mode, delete all characters between the cursor and the
beginning of the line, then enter insert mode.
.RE

.sp
.ne 2
.na
\fBvi-change-to-column\fR
.ad
.RS 30n
From \fBvi\fR command mode, delete the characters from the cursor up to the
column that is specified by the repeat count, then enter insert mode.
.RE

.sp
.ne 2
.na
\fBvi-change-to-parenthesis\fR
.ad
.RS 30n
Delete the characters from the cursor up to and including the matching
parenthesis, or next close parenthesis, then enter \fBvi\fR insert mode.
.RE

.sp
.ne 2
.na
\fBvi-forward-change-find\fR
.ad
.RS 30n
From \fBvi\fR command mode, delete the characters from the cursor up to and
including the following occurence of the next character typed, then enter
insert mode.
.RE

.sp
.ne 2
.na
\fBvi-backward-change-find\fR
.ad
.RS 30n
From vi command mode, delete the characters from the cursor up to and including
the preceding occurence of the next character typed, then enter insert mode.
.RE

.sp
.ne 2
.na
\fBvi-forward-change-to\fR
.ad
.RS 30n
From \fBvi\fR command mode, delete the characters from the cursor up to, but
not including, the following occurence of the next character typed, then enter
insert mode.
.RE

.sp
.ne 2
.na
\fBvi-backward-change-to\fR
.ad
.RS 30n
From \fBvi\fR command mode, delete the characters from the cursor up to, but
not including, the preceding occurence of the next character typed, then enter
insert mode.
.RE

.sp
.ne 2
.na
\fBvi-change-refind\fR
.ad
.RS 30n
Repeat the last vi-*-change-find or vi-*-change-to action.
.RE

.sp
.ne 2
.na
\fBvi-change-invert-refind\fR
.ad
.RS 30n
Repeat the last vi-*-change-find or vi-*-change-to action, in the opposite
direction.
.RE

.sp
.ne 2
.na
\fBvi-undo\fR
.ad
.RS 30n
In \fBvi\fR mode, undo the last editing operation.
.RE

.sp
.ne 2
.na
\fBvi-repeat-change\fR
.ad
.RS 30n
In \fBvi\fR command mode, repeat the last command that modified the line.
.RE

.SS "Default Key Bindings In \fBemacs\fR Mode"
.sp
.LP
The following default key bindings, which can be overriden by the tecla
configuration file, are designed to mimic most of the bindings of the unix
\fBtcsh shell\fR shell, when it is in \fBemacs\fR editing mode.
.sp
.LP
This is the default editing mode of the tecla library.
.sp
.LP
Under UNIX the terminal driver sets a number of special keys for certain
functions. The tecla library attempts to use the same key bindings to maintain
consistency. The key sequences shown for the following 6 bindings are thus just
examples of what they will probably be set to. If you have used the stty
command to change these keys, then the default bindings should match.
.sp
.ne 2
.na
\fB\fB^C\fR\fR
.ad
.RS 6n
user-interrupt
.RE

.sp
.ne 2
.na
\fB\fB^\\fR\fR
.ad
.RS 6n
abort
.RE

.sp
.ne 2
.na
\fB\fB^Z\fR\fR
.ad
.RS 6n
suspend
.RE

.sp
.ne 2
.na
\fB\fB^Q\fR\fR
.ad
.RS 6n
start-output
.RE

.sp
.ne 2
.na
\fB\fB^S\fR\fR
.ad
.RS 6n
stop-output
.RE

.sp
.ne 2
.na
\fB\fB^V\fR\fR
.ad
.RS 6n
literal-next
.RE

.sp
.LP
The cursor keys are refered to by name, as follows. This is necessary because
different types of terminals generate different key sequences when their cursor
keys are pressed.
.sp
.ne 2
.na
\fBright\fR
.ad
.RS 9n
cursor-right
.RE

.sp
.ne 2
.na
\fBleft\fR
.ad
.RS 9n
cursor-left
.RE

.sp
.ne 2
.na
\fBup\fR
.ad
.RS 9n
up-history
.RE

.sp
.ne 2
.na
\fBdown\fR
.ad
.RS 9n
down-history
.RE

.sp
.LP
The remaining bindings don't depend on the terminal setttings.
.sp
.ne 2
.na
\fB\fB^F\fR\fR
.ad
.RS 21n
cursor-right
.RE

.sp
.ne 2
.na
\fB\fB^B\fR\fR
.ad
.RS 21n
cursor-left
.RE

.sp
.ne 2
.na
\fB\fBM-i\fR\fR
.ad
.RS 21n
insert-mode
.RE

.sp
.ne 2
.na
\fB\fB^A\fR\fR
.ad
.RS 21n
beginning-of-line
.RE

.sp
.ne 2
.na
\fB\fB^E\fR\fR
.ad
.RS 21n
end-of-line
.RE

.sp
.ne 2
.na
\fB\fB^U\fR\fR
.ad
.RS 21n
delete-line
.RE

.sp
.ne 2
.na
\fB\fB^K\fR\fR
.ad
.RS 21n
kill-line
.RE

.sp
.ne 2
.na
\fB\fBM-f\fR\fR
.ad
.RS 21n
forward-word
.RE

.sp
.ne 2
.na
\fB\fBM-b\fR\fR
.ad
.RS 21n
backward-word
.RE

.sp
.ne 2
.na
\fB\fB^D\fR\fR
.ad
.RS 21n
del-char-or-list-or-eof
.RE

.sp
.ne 2
.na
\fB\fB^H\fR\fR
.ad
.RS 21n
backward-delete-char
.RE

.sp
.ne 2
.na
\fB\fB^?\fR\fR
.ad
.RS 21n
backward-delete-char
.RE

.sp
.ne 2
.na
\fB\fBM-d\fR\fR
.ad
.RS 21n
forward-delete-word
.RE

.sp
.ne 2
.na
\fB\fBM-^H\fR\fR
.ad
.RS 21n
backward-delete-word
.RE

.sp
.ne 2
.na
\fB\fBM-^?\fR\fR
.ad
.RS 21n
backward-delete-word
.RE

.sp
.ne 2
.na
\fB\fBM-u\fR\fR
.ad
.RS 21n
upcase-word
.RE

.sp
.ne 2
.na
\fB\fBM-l\fR\fR
.ad
.RS 21n
downcase-word
.RE

.sp
.ne 2
.na
\fB\fBM-c\fR\fR
.ad
.RS 21n
capitalize-word
.RE

.sp
.ne 2
.na
\fB\fB^R\fR\fR
.ad
.RS 21n
redisplay
.RE

.sp
.ne 2
.na
\fB\fB^L\fR\fR
.ad
.RS 21n
clear-screen
.RE

.sp
.ne 2
.na
\fB\fB^T\fR\fR
.ad
.RS 21n
transpose-chars
.RE

.sp
.ne 2
.na
\fB\fB^@\fR\fR
.ad
.RS 21n
set-mark
.RE

.sp
.ne 2
.na
\fB\fB^X^X\fR\fR
.ad
.RS 21n
exchange-point-and-mark
.RE

.sp
.ne 2
.na
\fB\fB^W\fR\fR
.ad
.RS 21n
kill-region
.RE

.sp
.ne 2
.na
\fB\fBM-w\fR\fR
.ad
.RS 21n
copy-region-as-kill
.RE

.sp
.ne 2
.na
\fB\fB^Y\fR\fR
.ad
.RS 21n
yank
.RE

.sp
.ne 2
.na
\fB\fB^P\fR\fR
.ad
.RS 21n
up-history
.RE

.sp
.ne 2
.na
\fB\fB^N\fR\fR
.ad
.RS 21n
down-history
.RE

.sp
.ne 2
.na
\fB\fBM-p\fR\fR
.ad
.RS 21n
history-search-backward
.RE

.sp
.ne 2
.na
\fB\fBM-n\fR\fR
.ad
.RS 21n
history-search-forward
.RE

.sp
.ne 2
.na
\fB\fB^I\fR\fR
.ad
.RS 21n
complete-word
.RE

.sp
.ne 2
.na
\fB\fB^X*\fR\fR
.ad
.RS 21n
expand-filename
.RE

.sp
.ne 2
.na
\fB\fB^X^F\fR\fR
.ad
.RS 21n
read-from-file
.RE

.sp
.ne 2
.na
\fB\fB^X^R\fR\fR
.ad
.RS 21n
read-init-files
.RE

.sp
.ne 2
.na
\fB\fB^Xg\fR\fR
.ad
.RS 21n
list-glob
.RE

.sp
.ne 2
.na
\fB\fB^Xh\fR\fR
.ad
.RS 21n
list-history
.RE

.sp
.ne 2
.na
\fB\fBM-<\fR\fR
.ad
.RS 21n
beginning-of-history
.RE

.sp
.ne 2
.na
\fB\fBM->\fR\fR
.ad
.RS 21n
end-of-history
.RE

.sp
.ne 2
.na
\fB\fB\en\fR\fR
.ad
.RS 21n
newline
.RE

.sp
.ne 2
.na
\fB\fB\er\fR\fR
.ad
.RS 21n
newline
.RE

.sp
.ne 2
.na
\fB\fBM-o\fR\fR
.ad
.RS 21n
repeat-history
.RE

.sp
.ne 2
.na
\fB\fBM-^V\fR\fR
.ad
.RS 21n
\fBvi\fR-mode
.RE

.sp
.ne 2
.na
\fB\fBM-0, M-1, ... M-9\fR\fR
.ad
.RS 21n
digit-argument (see below)
.RE

.sp
.LP
Note that \fB^I\fR is what the TAB key generates, and that \fB^@\fR can be
generated not only by pressing the CONTROL key and the @ key simultaneously,
but also by pressing the CONTROL key and the space bar at the same time.
.SS "Default Key Bindings in \fBvi\fR Mode"
.sp
.LP
The following default key bindings are designed to mimic the \fBvi\fR style of
editing as closely as possible. This means that very few editing functions are
provided in the initial character input mode, editing functions instead being
provided by the \fBvi\fR command mode. The \fBvi\fR command mode is entered
whenever the ESCAPE character is pressed, or whenever a key sequence that
starts with a meta character is entered. In addition to mimicing \fBvi\fR,
\fBlibtecla\fR provides bindings for tab completion, wild-card expansion of
file names, and historical line recall.
.sp
.LP
To learn how to tell the tecla library to use \fBvi\fR mode instead of the
default \fBemacs\fR editing mode, see the earlier section entitled The Tecla
Configuration File.
.sp
.LP
Under UNIX the terminal driver sets a number of special keys for certain
functions. The tecla library attempts to use the same key bindings to maintain
consistency, binding them both in input mode and in command mode. The key
sequences shown for the following 6 bindings are thus just examples of what
they will probably be set to. If you have used the \fBstty\fR command to change
these keys, then the default bindings should match.
.sp
.ne 2
.na
\fB\fB^C\fR\fR
.ad
.RS 8n
user-interrupt
.RE

.sp
.ne 2
.na
\fB\fB^\\fR\fR
.ad
.RS 8n
abort
.RE

.sp
.ne 2
.na
\fB\fB^Z\fR\fR
.ad
.RS 8n
suspend
.RE

.sp
.ne 2
.na
\fB\fB^Q\fR\fR
.ad
.RS 8n
start-output
.RE

.sp
.ne 2
.na
\fB\fB^S\fR\fR
.ad
.RS 8n
stop-output
.RE

.sp
.ne 2
.na
\fB\fB^V\fR\fR
.ad
.RS 8n
literal-next
.RE

.sp
.ne 2
.na
\fB\fBM-^C\fR\fR
.ad
.RS 8n
user-interrupt
.RE

.sp
.ne 2
.na
\fB\fBM-^\\fR\fR
.ad
.RS 8n
abort
.RE

.sp
.ne 2
.na
\fB\fBM-^Z\fR\fR
.ad
.RS 8n
suspend
.RE

.sp
.ne 2
.na
\fB\fBM-^Q\fR\fR
.ad
.RS 8n
start-output
.RE

.sp
.ne 2
.na
\fB\fBM-^S\fR\fR
.ad
.RS 8n
stop-output
.RE

.sp
.LP
Note that above, most of the bindings are defined twice, once as a raw control
code like \fB^C\fR and then a second time as a META character like \fBM-^C\fR.
The former is the binding for \fBvi\fR input mode, whereas the latter is the
binding for \fBvi\fR command mode. Once in command mode all key sequences that
the user types that they don't explicitly start with an ESCAPE or a META key,
have their first key secretly converted to a META character before the key
sequence is looked up in the key binding table. Thus, once in command mode,
when you type the letter i, for example, the tecla library actually looks up
the binding for \fBM-i\fR.
.sp
.LP
The cursor keys are refered to by name, as follows. This is necessary because
different types of terminals generate different key sequences when their cursor
keys are pressed.
.sp
.ne 2
.na
\fB\fBright\fR\fR
.ad
.RS 9n
cursor-right
.RE

.sp
.ne 2
.na
\fB\fBleft\fR\fR
.ad
.RS 9n
cursor-left
.RE

.sp
.ne 2
.na
\fB\fBup\fR\fR
.ad
.RS 9n
up-history
.RE

.sp
.ne 2
.na
\fB\fBdown\fR\fR
.ad
.RS 9n
down-history
.RE

.sp
.LP
The cursor keys normally generate a key sequence that start with an ESCAPE
character, so beware that using the arrow keys will put you into command mode
(if you aren't already in command mode).
.sp
.LP
The following are the terminal-independent key bindings for \fBvi\fR input
mode.
.sp
.ne 2
.na
\fB\fB^D\fR\fR
.ad
.RS 8n
list-or-eof
.RE

.sp
.ne 2
.na
\fB\fB^G\fR\fR
.ad
.RS 8n
list-glob
.RE

.sp
.ne 2
.na
\fB\fB^H\fR\fR
.ad
.RS 8n
backward-delete-char
.RE

.sp
.ne 2
.na
\fB\fB^I\fR\fR
.ad
.RS 8n
complete-word
.RE

.sp
.ne 2
.na
\fB\fB\er\fR\fR
.ad
.RS 8n
newline
.RE

.sp
.ne 2
.na
\fB\fB\en\fR\fR
.ad
.RS 8n
newline
.RE

.sp
.ne 2
.na
\fB\fB^L\fR\fR
.ad
.RS 8n
clear-screen
.RE

.sp
.ne 2
.na
\fB\fB^N\fR\fR
.ad
.RS 8n
down-history
.RE

.sp
.ne 2
.na
\fB\fB^P\fR\fR
.ad
.RS 8n
up-history
.RE

.sp
.ne 2
.na
\fB\fB^R\fR\fR
.ad
.RS 8n
redisplay
.RE

.sp
.ne 2
.na
\fB\fB^U\fR\fR
.ad
.RS 8n
backward-kill-line
.RE

.sp
.ne 2
.na
\fB\fB^W\fR\fR
.ad
.RS 8n
backward-delete-word
.RE

.sp
.ne 2
.na
\fB\fB^X*\fR\fR
.ad
.RS 8n
expand-filename
.RE

.sp
.ne 2
.na
\fB\fB^X^F\fR\fR
.ad
.RS 8n
read-from-file
.RE

.sp
.ne 2
.na
\fB\fB^X^R\fR\fR
.ad
.RS 8n
read-init-files
.RE

.sp
.ne 2
.na
\fB\fB^?\fR\fR
.ad
.RS 8n
backward-delete-char
.RE

.sp
.LP
The following are the key bindings that are defined in \fBvi\fR command mode,
this being specified by them all starting with a META character. As mentioned
above, once in command mode the initial meta character is optional. For
example, you might enter command mode by typing ESCAPE, and then press 'H'
twice to move the cursor two positions to the left. Both 'H' characters get
quietly converted to \fBM-h\fR before being compared to the key binding table,
the first one because ESCAPE followed by a character is always converted to the
equivalent META character, and the second because command mode was already
active.
.sp
.ne 2
.na
\fB\fBM-\\fR\fR
.ad
.RS 21n
cursor-right (META-space)
.RE

.sp
.ne 2
.na
\fB\fBM-$\fR\fR
.ad
.RS 21n
end-of-line
.RE

.sp
.ne 2
.na
\fB\fBM-*\fR\fR
.ad
.RS 21n
expand-filename
.RE

.sp
.ne 2
.na
\fB\fBM-+\fR\fR
.ad
.RS 21n
down-history
.RE

.sp
.ne 2
.na
\fB\fBM--\fR\fR
.ad
.RS 21n
up-history
.RE

.sp
.ne 2
.na
\fB\fBM-<\fR\fR
.ad
.RS 21n
beginning-of-history
.RE

.sp
.ne 2
.na
\fB\fBM->\fR\fR
.ad
.RS 21n
end-of-history
.RE

.sp
.ne 2
.na
\fB\fBM-^\fR\fR
.ad
.RS 21n
beginning-of-line
.RE

.sp
.ne 2
.na
\fB\fBM-\fR\fR
.ad
.RS 21n
repeat-find-char
.RE

.sp
.ne 2
.na
\fB\fBM-,\fR\fR
.ad
.RS 21n
invert-refind-char
.RE

.sp
.ne 2
.na
\fB\fBM-|\fR\fR
.ad
.RS 21n
goto-column
.RE

.sp
.ne 2
.na
\fB\fBM-~\fR\fR
.ad
.RS 21n
change-case
.RE

.sp
.ne 2
.na
\fB\fBM-.\fR\fR
.ad
.RS 21n
vi-repeat-change
.RE

.sp
.ne 2
.na
\fB\fBM-%\fR\fR
.ad
.RS 21n
find-parenthesis
.RE

.sp
.ne 2
.na
\fB\fBM-a\fR\fR
.ad
.RS 21n
vi-append
.RE

.sp
.ne 2
.na
\fB\fBM-A\fR\fR
.ad
.RS 21n
vi-append-at-eol
.RE

.sp
.ne 2
.na
\fB\fBM-b\fR\fR
.ad
.RS 21n
backward-word
.RE

.sp
.ne 2
.na
\fB\fBM-B\fR\fR
.ad
.RS 21n
backward-word
.RE

.sp
.ne 2
.na
\fB\fBM-C\fR\fR
.ad
.RS 21n
vi-change-rest-of-line
.RE

.sp
.ne 2
.na
\fB\fBM-cb\fR\fR
.ad
.RS 21n
vi-backward-change-word
.RE

.sp
.ne 2
.na
\fB\fBM-cB\fR\fR
.ad
.RS 21n
vi-backward-change-word
.RE

.sp
.ne 2
.na
\fB\fBM-cc\fR\fR
.ad
.RS 21n
vi-change-line
.RE

.sp
.ne 2
.na
\fB\fBM-ce\fR\fR
.ad
.RS 21n
vi-forward-change-word
.RE

.sp
.ne 2
.na
\fB\fBM-cE\fR\fR
.ad
.RS 21n
vi-forward-change-word
.RE

.sp
.ne 2
.na
\fB\fBM-cw\fR\fR
.ad
.RS 21n
vi-forward-change-word
.RE

.sp
.ne 2
.na
\fB\fBM-cW\fR\fR
.ad
.RS 21n
vi-forward-change-word
.RE

.sp
.ne 2
.na
\fB\fBM-cF\fR\fR
.ad
.RS 21n
vi-backward-change-find
.RE

.sp
.ne 2
.na
\fB\fBM-cf\fR\fR
.ad
.RS 21n
vi-forward-change-find
.RE

.sp
.ne 2
.na
\fB\fBM-cT\fR\fR
.ad
.RS 21n
vi-backward-change-to
.RE

.sp
.ne 2
.na
\fB\fBM-ct\fR\fR
.ad
.RS 21n
vi-forward-change-to
.RE

.sp
.ne 2
.na
\fB\fBM-c;\fR\fR
.ad
.RS 21n
vi-change-refind
.RE

.sp
.ne 2
.na
\fB\fBM-c,\fR\fR
.ad
.RS 21n
vi-change-invert-refind
.RE

.sp
.ne 2
.na
\fB\fBM-ch\fR\fR
.ad
.RS 21n
vi-backward-change-char
.RE

.sp
.ne 2
.na
\fB\fBM-c^H\fR\fR
.ad
.RS 21n
vi-backward-change-char
.RE

.sp
.ne 2
.na
\fB\fBM-c^?\fR\fR
.ad
.RS 21n
vi-backward-change-char
.RE

.sp
.ne 2
.na
\fB\fBM-cl\fR\fR
.ad
.RS 21n
vi-forward-change-char
.RE

.sp
.ne 2
.na
\fB\fBM-c\\fR\fR
.ad
.RS 21n
vi-forward-change-char (META-c-space)
.RE

.sp
.ne 2
.na
\fB\fBM-c^\fR\fR
.ad
.RS 21n
vi-change-to-bol
.RE

.sp
.ne 2
.na
\fB\fBM-c0\fR\fR
.ad
.RS 21n
vi-change-to-bol
.RE

.sp
.ne 2
.na
\fB\fBM-c$\fR\fR
.ad
.RS 21n
vi-change-rest-of-line
.RE

.sp
.ne 2
.na
\fB\fBM-c|\fR\fR
.ad
.RS 21n
vi-change-to-column
.RE

.sp
.ne 2
.na
\fB\fBM-c%\fR\fR
.ad
.RS 21n
vi-change-to-parenthesis
.RE

.sp
.ne 2
.na
\fB\fBM-dh\fR\fR
.ad
.RS 21n
backward-delete-char
.RE

.sp
.ne 2
.na
\fB\fBM-d^H\fR\fR
.ad
.RS 21n
backward-delete-char
.RE

.sp
.ne 2
.na
\fB\fBM-d^?\fR\fR
.ad
.RS 21n
backward-delete-char
.RE

.sp
.ne 2
.na
\fB\fBM-dl\fR\fR
.ad
.RS 21n
forward-delete-char
.RE

.sp
.ne 2
.na
\fB\fBM-d\fR\fR
.ad
.RS 21n
forward-delete-char (META-d-space)
.RE

.sp
.ne 2
.na
\fB\fBM-dd\fR\fR
.ad
.RS 21n
delete-line
.RE

.sp
.ne 2
.na
\fB\fBM-db\fR\fR
.ad
.RS 21n
backward-delete-word
.RE

.sp
.ne 2
.na
\fB\fBM-dB\fR\fR
.ad
.RS 21n
backward-delete-word
.RE

.sp
.ne 2
.na
\fB\fBM-de\fR\fR
.ad
.RS 21n
forward-delete-word
.RE

.sp
.ne 2
.na
\fB\fBM-dE\fR\fR
.ad
.RS 21n
forward-delete-word
.RE

.sp
.ne 2
.na
\fB\fBM-dw\fR\fR
.ad
.RS 21n
forward-delete-word
.RE

.sp
.ne 2
.na
\fB\fBM-dW\fR\fR
.ad
.RS 21n
forward-delete-word
.RE

.sp
.ne 2
.na
\fB\fBM-dF\fR\fR
.ad
.RS 21n
backward-delete-find
.RE

.sp
.ne 2
.na
\fB\fBM-df\fR\fR
.ad
.RS 21n
forward-delete-find
.RE

.sp
.ne 2
.na
\fB\fBM-dT\fR\fR
.ad
.RS 21n
backward-delete-to
.RE

.sp
.ne 2
.na
\fB\fBM-dt\fR\fR
.ad
.RS 21n
forward-delete-to
.RE

.sp
.ne 2
.na
\fB\fBM-d;\fR\fR
.ad
.RS 21n
delete-refind
.RE

.sp
.ne 2
.na
\fB\fBM-d,\fR\fR
.ad
.RS 21n
delete-invert-refind
.RE

.sp
.ne 2
.na
\fB\fBM-d^\fR\fR
.ad
.RS 21n
backward-kill-line
.RE

.sp
.ne 2
.na
\fB\fBM-d0\fR\fR
.ad
.RS 21n
backward-kill-line
.RE

.sp
.ne 2
.na
\fB\fBM-d$\fR\fR
.ad
.RS 21n
kill-line
.RE

.sp
.ne 2
.na
\fB\fBM-D\fR\fR
.ad
.RS 21n
kill-line
.RE

.sp
.ne 2
.na
\fB\fBM-d|\fR\fR
.ad
.RS 21n
delete-to-column
.RE

.sp
.ne 2
.na
\fB\fBM-d%\fR\fR
.ad
.RS 21n
delete-to-parenthesis
.RE

.sp
.ne 2
.na
\fB\fBM-e\fR\fR
.ad
.RS 21n
forward-word
.RE

.sp
.ne 2
.na
\fB\fBM-E\fR\fR
.ad
.RS 21n
forward-word
.RE

.sp
.ne 2
.na
\fB\fBM-f\fR\fR
.ad
.RS 21n
forward-find-char
.RE

.sp
.ne 2
.na
\fB\fBM-F\fR\fR
.ad
.RS 21n
backward-find-char
.RE

.sp
.ne 2
.na
\fB\fBM--\fR\fR
.ad
.RS 21n
up-history
.RE

.sp
.ne 2
.na
\fB\fBM-h\fR\fR
.ad
.RS 21n
cursor-left
.RE

.sp
.ne 2
.na
\fB\fBM-H\fR\fR
.ad
.RS 21n
beginning-of-history
.RE

.sp
.ne 2
.na
\fB\fBM-i\fR\fR
.ad
.RS 21n
vi-insert
.RE

.sp
.ne 2
.na
\fB\fBM-I\fR\fR
.ad
.RS 21n
vi-insert-at-bol
.RE

.sp
.ne 2
.na
\fB\fBM-j\fR\fR
.ad
.RS 21n
down-history
.RE

.sp
.ne 2
.na
\fB\fBM-J\fR\fR
.ad
.RS 21n
history-search-forward
.RE

.sp
.ne 2
.na
\fB\fBM-k\fR\fR
.ad
.RS 21n
up-history
.RE

.sp
.ne 2
.na
\fB\fBM-K\fR\fR
.ad
.RS 21n
history-search-backward
.RE

.sp
.ne 2
.na
\fB\fBM-l\fR\fR
.ad
.RS 21n
cursor-right
.RE

.sp
.ne 2
.na
\fB\fBM-L\fR\fR
.ad
.RS 21n
end-of-history
.RE

.sp
.ne 2
.na
\fB\fBM-n\fR\fR
.ad
.RS 21n
history-re-search-forward
.RE

.sp
.ne 2
.na
\fB\fBM-N\fR\fR
.ad
.RS 21n
history-re-search-backward
.RE

.sp
.ne 2
.na
\fB\fBM-p\fR\fR
.ad
.RS 21n
append-yank
.RE

.sp
.ne 2
.na
\fB\fBM-P\fR\fR
.ad
.RS 21n
yank
.RE

.sp
.ne 2
.na
\fB\fBM-r\fR\fR
.ad
.RS 21n
vi-replace-char
.RE

.sp
.ne 2
.na
\fB\fBM-R\fR\fR
.ad
.RS 21n
vi-overwrite
.RE

.sp
.ne 2
.na
\fB\fBM-s\fR\fR
.ad
.RS 21n
vi-forward-change-char
.RE

.sp
.ne 2
.na
\fB\fBM-S\fR\fR
.ad
.RS 21n
vi-change-line
.RE

.sp
.ne 2
.na
\fB\fBM-t\fR\fR
.ad
.RS 21n
forward-to-char
.RE

.sp
.ne 2
.na
\fB\fBM-T\fR\fR
.ad
.RS 21n
backward-to-char
.RE

.sp
.ne 2
.na
\fB\fBM-u\fR\fR
.ad
.RS 21n
vi-undo
.RE

.sp
.ne 2
.na
\fB\fBM-w\fR\fR
.ad
.RS 21n
forward-to-word
.RE

.sp
.ne 2
.na
\fB\fBM-W\fR\fR
.ad
.RS 21n
forward-to-word
.RE

.sp
.ne 2
.na
\fB\fBM-x\fR\fR
.ad
.RS 21n
forward-delete-char
.RE

.sp
.ne 2
.na
\fB\fBM-X\fR\fR
.ad
.RS 21n
backward-delete-char
.RE

.sp
.ne 2
.na
\fB\fBM-yh\fR\fR
.ad
.RS 21n
backward-copy-char
.RE

.sp
.ne 2
.na
\fB\fBM-y^H\fR\fR
.ad
.RS 21n
backward-copy-char
.RE

.sp
.ne 2
.na
\fB\fBM-y^?\fR\fR
.ad
.RS 21n
backward-copy-char
.RE

.sp
.ne 2
.na
\fB\fBM-yl\fR\fR
.ad
.RS 21n
forward-copy-char
.RE

.sp
.ne 2
.na
\fB\fBM-y\\fR\fR
.ad
.RS 21n
forward-copy-char (META-y-space)
.RE

.sp
.ne 2
.na
\fB\fBM-ye\fR\fR
.ad
.RS 21n
forward-copy-word
.RE

.sp
.ne 2
.na
\fB\fBM-yE\fR\fR
.ad
.RS 21n
forward-copy-word
.RE

.sp
.ne 2
.na
\fB\fBM-yw\fR\fR
.ad
.RS 21n
forward-copy-word
.RE

.sp
.ne 2
.na
\fB\fBM-yW\fR\fR
.ad
.RS 21n
forward-copy-word
.RE

.sp
.ne 2
.na
\fB\fBM-yb\fR\fR
.ad
.RS 21n
backward-copy-word
.RE

.sp
.ne 2
.na
\fB\fBM-yB\fR\fR
.ad
.RS 21n
backward-copy-word
.RE

.sp
.ne 2
.na
\fB\fBM-yf\fR\fR
.ad
.RS 21n
forward-copy-find
.RE

.sp
.ne 2
.na
\fB\fBM-yF\fR\fR
.ad
.RS 21n
backward-copy-find
.RE

.sp
.ne 2
.na
\fB\fBM-yt\fR\fR
.ad
.RS 21n
forward-copy-to
.RE

.sp
.ne 2
.na
\fB\fBM-yT\fR\fR
.ad
.RS 21n
backward-copy-to
.RE

.sp
.ne 2
.na
\fB\fBM-y;\fR\fR
.ad
.RS 21n
copy-refind
.RE

.sp
.ne 2
.na
\fB\fBM-y,\fR\fR
.ad
.RS 21n
copy-invert-refind
.RE

.sp
.ne 2
.na
\fB\fBM-y^\fR\fR
.ad
.RS 21n
copy-to-bol
.RE

.sp
.ne 2
.na
\fB\fBM-y0\fR\fR
.ad
.RS 21n
copy-to-bol
.RE

.sp
.ne 2
.na
\fB\fBM-y$\fR\fR
.ad
.RS 21n
copy-rest-of-line
.RE

.sp
.ne 2
.na
\fB\fBM-yy\fR\fR
.ad
.RS 21n
copy-line
.RE

.sp
.ne 2
.na
\fB\fBM-Y\fR\fR
.ad
.RS 21n
copy-line
.RE

.sp
.ne 2
.na
\fB\fBM-y|\fR\fR
.ad
.RS 21n
copy-to-column
.RE

.sp
.ne 2
.na
\fB\fBM-y%\fR\fR
.ad
.RS 21n
copy-to-parenthesis
.RE

.sp
.ne 2
.na
\fB\fBM-^E\fR\fR
.ad
.RS 21n
emacs-mode
.RE

.sp
.ne 2
.na
\fB\fBM-^H\fR\fR
.ad
.RS 21n
cursor-left
.RE

.sp
.ne 2
.na
\fB\fBM-^?\fR\fR
.ad
.RS 21n
cursor-left
.RE

.sp
.ne 2
.na
\fB\fBM-^L\fR\fR
.ad
.RS 21n
clear-screen
.RE

.sp
.ne 2
.na
\fB\fBM-^N\fR\fR
.ad
.RS 21n
down-history
.RE

.sp
.ne 2
.na
\fB\fBM-^P\fR\fR
.ad
.RS 21n
up-history
.RE

.sp
.ne 2
.na
\fB\fBM-^R\fR\fR
.ad
.RS 21n
redisplay
.RE

.sp
.ne 2
.na
\fB\fBM-^D\fR\fR
.ad
.RS 21n
list-or-eof
.RE

.sp
.ne 2
.na
\fB\fBM-^I\fR\fR
.ad
.RS 21n
complete-word
.RE

.sp
.ne 2
.na
\fB\fBM-\r\fR\fR
.ad
.RS 21n
newline
.RE

.sp
.ne 2
.na
\fB\fBM-\en\fR\fR
.ad
.RS 21n
newline
.RE

.sp
.ne 2
.na
\fB\fBM-^X^R\fR\fR
.ad
.RS 21n
read-init-files
.RE

.sp
.ne 2
.na
\fB\fBM-^Xh\fR\fR
.ad
.RS 21n
list-history
.RE

.sp
.ne 2
.na
\fB\fBM-0, M-1, ... M-9\fR\fR
.ad
.RS 21n
digit-argument (see below)
.RE

.sp
.LP
Note that \fB^I\fR is what the TAB key generates.
.SS "Entering Repeat Counts"
.sp
.LP
Many of the key binding functions described previously, take an optional count,
typed in before the target key sequence. This is interpreted as a repeat count
by most bindings. A notable exception is the goto-column binding, which
interprets the count as a column number.
.sp
.LP
By default you can specify this count argument by pressing the META key while
typing in the numeric count. This relies on the digit-argument action being
bound to 'META-0', 'META-1' etc. Once any one of these bindings has been
activated, you can optionally take your finger off the META key to type in the
rest of the number, since every numeric digit thereafter is treated as part of
the number, unless it is preceded by the literal-next binding. As soon as a
non-digit, or literal digit key is pressed the repeat count is terminated and
either causes the just typed character to be added to the line that many times,
or causes the next key binding function to be given that argument.
.sp
.LP
For example, in \fBemacs\fR mode, typing:
.sp
.in +2
.nf
M-12a
.fi
.in -2

.sp
.LP
causes the letter 'a' to be added to the line 12 times, whereas
.sp
.in +2
.nf
M-4M-c
.fi
.in -2

.sp
.LP
Capitalizes the next 4 words.
.sp
.LP
In \fBvi\fR command mode the meta modifier is automatically added to all
characters typed in, so to enter a count in \fBvi\fR command-mode, just
involves typing in the number, just as it does in the \fBvi\fR editor itself.
So for example, in vi command mode, typing:
.sp
.in +2
.nf
4w2x
.fi
.in -2

.sp
.LP
moves the cursor four words to the right, then deletes two characters.
.sp
.LP
You can also bind digit-argument to other key sequences. If these end in a
numeric digit, that digit gets appended to the current repeat count. If it
doesn't end in a numeric digit, a new repeat count is started with a value of
zero, and can be completed by typing in the number, after letting go of the key
which triggered the digit-argument action.
.SH FILES
.sp
.ne 2
.na
\fB\fB/usr/lib/libtecla.so\fR\fR
.ad
.RS 27n
The tecla library
.RE

.sp
.ne 2
.na
\fB\fB/usr/include/libtecla.h\fR\fR
.ad
.RS 27n
The tecla header file
.RE

.sp
.ne 2
.na
\fB\fB~/.teclarc\fR\fR
.ad
.RS 27n
The personal tecla customization file
.RE

.SH ATTRIBUTES
.sp
.LP
See \fBattributes\fR(5) for descriptions of the following attributes:
.sp

.sp
.TS
box;
c | c
l | l .
ATTRIBUTE TYPE	ATTRIBUTE VALUE
_
Interface Stability	Evolving
.TE

.SH SEE ALSO
.sp
.LP
\fBvi\fR(1), \fBcpl_complete_word\fR(3TECLA), \fBef_expand_file\fR(3TECLA),
\fBgl_get_line\fR(3TECLA), \fBgl_io_mode\fR(3TECLA), \fBlibtecla\fR(3LIB),
\fBpca_lookup_file\fR(3TECLA), \fBattributes\fR(5)
