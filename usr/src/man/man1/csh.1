'\" te
.\" Copyright 1989 AT&T
.\" Copyright (c) 2007 Sun Microsystems, Inc. All Rights Reserved.
.\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
.\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
.TH CSH 1 "April 9, 2016"
.SH NAME
csh \- shell command interpreter with a C-like syntax
.SH SYNOPSIS
.LP
.nf
\fBcsh\fR [\fB-bcefinstvVxX\fR] [\fIargument\fR]...
.fi

.SH DESCRIPTION
.LP
\fBcsh\fR, the C shell, is a command interpreter with a syntax reminiscent of
the C language. It provides a number of convenient features for interactive use
that are not available with the Bourne shell, including filename completion,
command aliasing, history substitution, job control, and a number of built-in
commands. As with the Bourne shell, the C shell provides variable, command and
filename substitution.
.SS "Initialization and Termination"
.LP
When first started, the C shell normally performs commands from the
\fB\&.cshrc\fR file in your home directory, provided that it is readable and
you either own it or your real group \fBID\fR matches its group \fBID\fR. If
the shell is invoked with a name that starts with `\fB\(mi\fR\&', as when
started by \fBlogin\fR(1), the shell runs as a \fBlogin\fR shell.
.sp
.LP
If the shell is a login shell, this is the sequence of invocations: First,
commands in \fB/etc/.login\fR are executed. Next, commands from the
\fB\&.cshrc\fR file your \fBhome\fR directory are executed. Then the shell
executes commands from the \fB\&.login\fR file in your home directory; the same
permission checks as those for \fB\&.cshrc\fR are applied to this file.
Typically, the \fB\&.login\fR file contains commands to specify the terminal
type and environment. (For an explanation of file interpreters, see \fBCommand
Execution\fR and \fBexec\fR(2).)
.sp
.LP
As a login shell terminates, it performs commands from the \fB\&.logout\fR file
in your home directory; the same permission checks as those for \fB\&.cshrc\fR
are applied to this file.
.SS "Interactive Operation"
.LP
After startup processing is complete, an interactive C shell begins reading
commands from the terminal, prompting with \fBhostname\fR\fB%\fR (or
\fBhostname\fR\fB#\fR for the privileged user). The shell then repeatedly
performs the following actions: a line of command input is read and broken into
\fIwords\fR. This sequence of words is placed on the history list and then
parsed, as described under USAGE. Finally, the shell executes each command in
the current line.
.SS "Noninteractive Operation"
.LP
When running noninteractively, the shell does not prompt for input from the
terminal. A noninteractive C shell can execute a command supplied as an
\fIargument\fR on its command line, or interpret commands from a file, also
known as a script.
.SH OPTIONS
.LP
The following options are supported:
.sp
.ne 2
.na
\fB\fB-b\fR\fR
.ad
.RS 6n
Forced a "break" from option processing. Subsequent command line arguments are
not interpreted as C shell options. This allows the passing of options to a
script without confusion. The shell does not run set-user-ID or set-group-ID
scripts unless this option is present.
.RE

.sp
.ne 2
.na
\fB\fB-c\fR\fR
.ad
.RS 6n
Executes the first \fIargument\fR, which must be present. Remaining arguments
are placed in \fBargv\fR, the argument-list variable, and passed directly to
\fBcsh\fR.
.RE

.sp
.ne 2
.na
\fB\fB-e\fR\fR
.ad
.RS 6n
Exits if a command terminates abnormally or yields a nonzero exit status.
.RE

.sp
.ne 2
.na
\fB\fB-f\fR\fR
.ad
.RS 6n
Fast start. Reads neither the \fB\&.cshrc\fR file, nor the \fB\&.login\fR file
(if a login shell) upon startup.
.RE

.sp
.ne 2
.na
\fB\fB-i\fR\fR
.ad
.RS 6n
Forced interactive. Prompts for command line input, even if the standard input
does not appear to be a terminal (character-special device).
.RE

.sp
.ne 2
.na
\fB\fB-n\fR\fR
.ad
.RS 6n
Parses (interprets), but does not execute commands. This option can be used to
check C shell scripts for syntax errors.
.RE

.sp
.ne 2
.na
\fB\fB-s\fR\fR
.ad
.RS 6n
Takes commands from the standard input.
.RE

.sp
.ne 2
.na
\fB\fB-t\fR\fR
.ad
.RS 6n
Reads and executes a single command line. A `\fB\e\fR\&' (backslash) can be
used to escape each newline for continuation of the command line onto
subsequent input lines.
.RE

.sp
.ne 2
.na
\fB\fB-v\fR\fR
.ad
.RS 6n
Verbose. Sets the \fBverbose\fR predefined variable. Command input is echoed
after history substitution, but before other substitutions and before
execution.
.RE

.sp
.ne 2
.na
\fB\fB-V\fR\fR
.ad
.RS 6n
Sets \fBverbose\fR before reading \fB\&.cshrc\fR.
.RE

.sp
.ne 2
.na
\fB\fB-x\fR\fR
.ad
.RS 6n
Echo. Sets the \fBecho\fR variable. Echoes commands after all substitutions and
just before execution.
.RE

.sp
.ne 2
.na
\fB\fB-X\fR\fR
.ad
.RS 6n
Sets \fBecho\fR before reading \fB\&.cshrc\fR.
.RE

.sp
.LP
Except with the options \fB-c\fR, \fB-i\fR, \fB-s\fR, or \fB-t\fR, the first
nonoption \fIargument\fR is taken to be the name of a command or script. It is
passed as argument zero, and subsequent arguments are added to the argument
list for that command or script.
.SH USAGE
.SS "Filename Completion"
.LP
When enabled by setting the variable \fBfilec\fR, an interactive C shell can
complete a partially typed filename or user name. When an unambiguous partial
filename is followed by an \fBESC\fR character on the terminal input line, the
shell fills in the remaining characters of a matching filename from the working
directory.
.sp
.LP
If a partial filename is followed by the \fBEOF\fR character (usually typed as
Control-d), the shell lists all filenames that match. It then prompts once
again, supplying the incomplete command line typed in so far.
.sp
.LP
When the last (partial) word begins with a tilde (\fB~\fR), the shell attempts
completion with a user name, rather than a file in the working directory.
.sp
.LP
The terminal bell signals errors or multiple matches. This bell signal can be
inhibited by setting the variable \fBnobeep\fR. You can exclude files with
certain suffixes by listing those suffixes in the variable \fBfignore\fR. If,
however, the only possible completion includes a suffix in the list, it is not
ignored. \fBfignore\fR does not affect the listing of filenames by the
\fBEOF\fR character.
.SS "Lexical Structure"
.LP
The shell splits input lines into words at space and tab characters, except as
noted below. The characters \fB&\fR, \fB|\fR, \fB;\fR, \fB<\fR, \fB>\fR,
\fB(\fR, and \fB)\fR form separate words; if paired, the pairs form single
words. These shell metacharacters can be made part of other words, and their
special meaning can be suppressed by preceding them with a `\fB\e\fR\&'
(backslash). A newline preceded by a \fB\e\fR is equivalent to a space
character.
.sp
.LP
In addition, a string enclosed in matched pairs of single-quotes (\fB\&'\fR),
double-quotes (\fB"\fR), or backquotes (\fB`\fR), forms a partial word.
Metacharacters in such a string, including any space or tab characters, do not
form separate words. Within pairs of backquote (\fB`\fR) or double-quote
(\fB"\fR) characters, a newline preceded by a `\fB\e\fR\&' (backslash) gives a
true newline character. Additional functions of each type of quote are
described, below, under \fBVariable Substitution\fR, \fBCommand
Substitution\fR, and \fBFilename\fR \fBSubstitution\fR.
.sp
.LP
When the shell's input is not a terminal, the character \fB#\fR introduces a
comment that continues to the end of the input line. Its special meaning is
suppressed when preceded by a \fB\e\fR or enclosed in matching quotes.
.SS "Command Line Parsing"
.LP
A \fIsimple command\fR is composed of a sequence of words. The first word (that
is not part of an I/O redirection) specifies the command to be executed. A
simple command, or a set of simple commands separated by \fB|\fR or \fB|&\fR
characters, forms a \fIpipeline\fR. With \fB|\fR, the standard output of the
preceding command is redirected to the standard input of the command that
follows. With \fB|\|&\fR, both the standard error and the standard output are
redirected through the pipeline.
.sp
.LP
Pipelines can be separated by semicolons (\|\fB;\fR\|), in which case they are
executed sequentially. Pipelines that are separated by \fB&&\fR or \fB|\||\fR
form conditional sequences in which the execution of pipelines on the right
depends upon the success or failure, respectively, of the pipeline on the left.
.sp
.LP
A pipeline or sequence can be enclosed within parentheses `()' to form a simple
command that can be a component in a pipeline or sequence.
.sp
.LP
A sequence of pipelines can be executed asynchronously or "in the background"
by appending an `\fB&\fR\&'; rather than waiting for the sequence to finish
before issuing a prompt, the shell displays the job number (see \fBJob
Control\fR, below) and associated process IDs and prompts immediately.
.SS "History Substitution"
.LP
History substitution allows you to use words from previous command lines in the
command line you are typing. This simplifies spelling corrections and the
repetition of complicated commands or arguments. Command lines are saved in the
history list, the size of which is controlled by the \fBhistory\fR variable.
The most recent command is retained in any case. A history substitution begins
with a \fB!\fR (although you can change this with the \fBhistchars\fR variable)
and occurs anywhere on the command line; history substitutions do not nest. The
\fB!\fR can be escaped with \fB\e\fR to suppress its special meaning.
.sp
.LP
Input lines containing history substitutions are echoed on the terminal after
being expanded, but before any other substitutions take place or the command
gets executed.
.SS "Event Designators"
.LP
An event designator is a reference to a command line entry in the history list.
.sp
.ne 2
.na
\fB\fB!\fR\fR
.ad
.sp .6
.RS 4n
Start a history substitution, except when followed by a space character, tab,
newline, \fB=\fR or \fB(\fR.
.RE

.sp
.ne 2
.na
\fB\fB!!\fR\fR
.ad
.sp .6
.RS 4n
Refer to the previous command. By itself, this substitution repeats the
previous command.
.RE

.sp
.ne 2
.na
\fB\fB!\fR\fIn\fR\fR
.ad
.sp .6
.RS 4n
Refer to command line \fIn\fR.
.RE

.sp
.ne 2
.na
\fB\fB!\fR\fB-n\fR\fR
.ad
.sp .6
.RS 4n
Refer to the current command line minus \fIn\fR.
.RE

.sp
.ne 2
.na
\fB\fB!\fR\fIstr\fR\fR
.ad
.sp .6
.RS 4n
Refer to the most recent command starting with \fIstr\fR.
.RE

.sp
.ne 2
.na
\fB\fB!?\fR\fIstr\fR\fB?\fR\fR
.ad
.sp .6
.RS 4n
Refer to the most recent command containing \fIstr\fR.
.RE

.sp
.ne 2
.na
\fB\fB!?\fR\fIstr\fR\fB?\fR \fIadditional\fR\fR
.ad
.sp .6
.RS 4n
Refer to the most recent command containing \fIstr\fR and append
\fIadditional\fR to that referenced command.
.RE

.sp
.ne 2
.na
\fB\fB!{\fR\fIcommand\fR\fB}\fR \fIadditional\fR\fR
.ad
.sp .6
.RS 4n
Refer to the most recent command beginning with \fIcommand\fR and append
\fIadditional\fR to that referenced command.
.RE

.sp
.ne 2
.na
\fB\fB^\fR\fIprevious_word\fR\fB^\fR\fIreplacement\fR\fB^\fR\fR
.ad
.sp .6
.RS 4n
Repeat the previous command line replacing the string \fIprevious_word\fR with
the string \fIreplacement\fR. This is equivalent to the history substitution:
.sp
.in +2
.nf
!:s/\fIprevious_word\fR/\fIreplacement\fR/.
.fi
.in -2
.sp

To re-execute a specific previous command AND make such a substitution, say,
re-executing command #6,
.sp
.in +2
.nf
!:6s/\fIprevious_word\fR/\fIreplacement\fR/.
.fi
.in -2
.sp

.RE

.SS "Word Designators"
.LP
A `\fB:\fR' (colon) separates the event specification from the word designator.
It can be omitted if the word designator begins with a \fB^\fR, \fB$\fR,
\fB*\fR, \fB\(mi\fR or \fB%\fR. If the word is to be selected from the previous
command, the second \fB!\fR character can be omitted from the event
specification. For instance, \fB!!:1\fR and \fB!:1\fR both refer to the first
word of the previous command, while \fB!!$\fR and \fB!$\fR both refer to the
last word in the previous command. Word designators include:
.sp
.ne 2
.na
\fB\fB#\fR\fR
.ad
.RS 10n
The entire command line typed so far.
.RE

.sp
.ne 2
.na
\fB\fB0\fR\fR
.ad
.RS 10n
The first input word (command).
.RE

.sp
.ne 2
.na
\fB\fIn\fR\fR
.ad
.RS 10n
The \fIn\fR'th argument.
.RE

.sp
.ne 2
.na
\fB\fB^\fR\fR
.ad
.RS 10n
The first argument, that is, \fB1\fR.
.RE

.sp
.ne 2
.na
\fB\fB$\fR\fR
.ad
.RS 10n
The last argument.
.RE

.sp
.ne 2
.na
\fB\fB%\fR\fR
.ad
.RS 10n
The word matched by the \fB?\fR\fIs\fR search.
.RE

.sp
.ne 2
.na
\fB\fIx\fR\fB\(mi\fR\fIy\fR\fR
.ad
.RS 10n
A range of words; \fB\(mi\fR\fIy\fR abbreviates \fB0\(mi\fR\fIy\fR.
.RE

.sp
.ne 2
.na
\fB\fB*\fR\fR
.ad
.RS 10n
All the arguments, or a null value if there is just one word in the event.
.RE

.sp
.ne 2
.na
\fB\fIx\fR\fB*\fR\fR
.ad
.RS 10n
Abbreviates \fIx\fR\fB\(mi$\fR\fI\&.\fR
.RE

.sp
.ne 2
.na
\fB\fIx\fR\fB\(mi\fR\fR
.ad
.RS 10n
Like \fIx*\fR but omitting word \fB$\fR.
.RE

.SS "Modifiers"
.LP
After the optional word designator, you can add one of the following modifiers,
preceded by a \fB:\fR.
.sp
.ne 2
.na
\fB\fBh\fR\fR
.ad
.RS 10n
Remove a trailing pathname component, leaving the head.
.RE

.sp
.ne 2
.na
\fB\fBr\fR\fR
.ad
.RS 10n
Remove a trailing suffix of the form `\fB\&.\fR\fIxxx\fR', leaving the
basename.
.RE

.sp
.ne 2
.na
\fB\fBe\fR\fR
.ad
.RS 10n
Remove all but the suffix, leaving the Extension.
.RE

.sp
.ne 2
.na
\fB\fBs/\fR\fIl\fR\fB/\fR\fIr\fR\fB/\fR\fR
.ad
.RS 10n
Substitute \fIr\fR for \fIl\fR.
.RE

.sp
.ne 2
.na
\fB\fBt\fR\fR
.ad
.RS 10n
Remove all leading pathname components, leaving the tail.
.RE

.sp
.ne 2
.na
\fB\fB&\fR\fR
.ad
.RS 10n
Repeat the previous substitution.
.RE

.sp
.ne 2
.na
\fB\fBg\fR\fR
.ad
.RS 10n
Apply the change to the first occurrence of a match in each word, by prefixing
the above (for example, \fBg&\fR).
.RE

.sp
.ne 2
.na
\fB\fBp\fR\fR
.ad
.RS 10n
Print the new command but do not execute it.
.RE

.sp
.ne 2
.na
\fB\fBq\fR\fR
.ad
.RS 10n
Quote the substituted words,escaping further substitutions.
.RE

.sp
.ne 2
.na
\fB\fBx\fR\fR
.ad
.RS 10n
Like \fBq\fR, but break into words at each space character, tab or newline.
.RE

.sp
.LP
Unless preceded by a \fBg\fR, the modification is applied only to the first
string that matches \fIl\fR; an error results if no string matches.
.sp
.LP
The left-hand side of substitutions are not regular expressions, but character
strings. Any character can be used as the delimiter in place of \fB/\fR. A
backslash quotes the delimiter character. The character \fB&\fR, in the right
hand side, is replaced by the text from the left-hand-side. The \fB&\fR can be
quoted with a backslash. A null \fIl\fR uses the previous string either from a
\fIl\fR or from a contextual scan string \fIs\fR from \fB!?\fR\fIs\fR. You can
omit the rightmost delimiter if a newline immediately follows \fIr\fR; the
rightmost \fB?\fR in a context scan can similarly be omitted.
.sp
.LP
Without an event specification, a history reference refers either to the
previous command, or to a previous history reference on the command line (if
any).
.SS "Quick Substitution"
.ne 2
.na
\fB\fB^\fR\fIl\fR\fB^\fR\fIr\fR\fB^\fR\fR
.ad
.RS 9n
This is equivalent to the history substitution:
.sp
.in +2
.nf
!:s/\fIl\fR/\fIr\fR/.
.fi
.in -2
.sp

.RE

.SS "Aliases"
.LP
The C shell maintains a list of aliases that you can create, display, and
modify using the \fBalias\fR and \fBunalias\fR commands. The shell checks the
first word in each command to see if it matches the name of an existing alias.
If it does, the command is reprocessed with the alias definition replacing its
name; the history substitution mechanism is made available as though that
command were the previous input line. This allows history substitutions,
escaped with a backslash in the definition, to be replaced with actual command
line arguments when the alias is used. If no history substitution is called
for, the arguments remain unchanged.
.sp
.LP
Aliases can be nested. That is, an alias definition can contain the name of
another alias. Nested aliases are expanded before any history substitutions is
applied. This is useful in pipelines such as
.sp
.in +2
.nf
\fBalias lm 'ls -l \e!* | more'\fR
.fi
.in -2
.sp

.sp
.LP
which when called, pipes the output of \fBls\fR(1) through \fBmore\fR(1).
.sp
.LP
Except for the first word, the name of the alias can not appear in its
definition, nor in any alias referred to by its definition. Such loops are
detected, and cause an error message.
.SS "I/O Redirection"
.LP
The following metacharacters indicate that the subsequent word is the name of a
file to which the command's standard input, standard output, or standard error
is redirected; this word is variable, command, and filename expanded separately
from the rest of the command.
.sp
.ne 2
.na
\fB\fB<\fR\fR
.ad
.RS 15n
Redirect the standard input.
.RE

.sp
.ne 2
.na
\fB\fB<\|<\fR\fI\|word\fR\fR
.ad
.RS 15n
Read the standard input, up to a line that is identical with \fIword\fR, and
place the resulting lines in a temporary file. Unless \fIword\fR is escaped or
quoted, variable and command substitutions are performed on these lines. Then,
the pipeline is invoked with the temporary file as its standard input.
\fIword\fR is not subjected to variable, filename, or command substitution, and
each line is compared to it before any substitutions are performed by the
shell.
.RE

.sp
.ne 2
.na
\fB\fB>\fR \fB>!\fR \fB>&\fR \fB>&!\fR\fR
.ad
.RS 15n
Redirect the standard output to a file. If the file does not exist, it is
created. If it does exist, it is overwritten; its previous contents are lost.
.sp
When set, the variable \fBnoclobber\fR prevents destruction of existing files.
It also prevents redirection to terminals and \fB/dev/null\fR, unless one of
the \fB!\fR forms is used. The \fB&\fR forms redirect both standard output and
the standard error (diagnostic output) to the file.
.RE

.sp
.ne 2
.na
\fB\fB>\|>\fR \fB>\|>&\fR \fB>\|>!\fR \fB>\|>&!\fR\fR
.ad
.RS 27n
Append the standard output. Like \fB>\fR, but places output at the end of the
file rather than overwriting it. If \fBnoclobber\fR is set, it is an error for
the file not to exist, unless one of the \fB!\fR forms is used. The \fB&\fR
forms append both the standard error and standard output to the file.
.RE

.SS "Variable Substitution"
.LP
The C shell maintains a set of variables, each of which is composed of a
\fIname\fR and a \fIvalue\fR. A variable name consists of up to 128 letters and
digits, and starts with a letter. An underscore (\fB_\fR) is considered a
letter). A variable's value is a space-separated list of zero or more words. If
the shell supports a variable name up to 128 characters the variable
\fBSUNW_VARLEN\fR is defined. If a variable name of up to 128 characters is not
supported, then an older version of the shell is being used, and the shell
variable name length has a maximum length of 20.
.sp
.LP
To refer to a variable's value, precede its name with a `\fB$\fR'. Certain
references (described below) can be used to select specific words from the
value, or to display other information about the variable. Braces can be used
to insulate the reference from other characters in an input-line word.
.sp
.LP
Variable substitution takes place after the input line is analyzed, aliases are
resolved, and I/O redirections are applied. Exceptions to this are variable
references in I/O redirections (substituted at the time the redirection is
made), and backquoted strings (see Command Substitution).
.sp
.LP
Variable substitution can be suppressed by preceding the \fB$\fR with a
\fB\e\fR, except within double-quotes where it always occurs. Variable
substitution is suppressed inside of single-quotes. A \fB$\fR is escaped if
followed by a space character, tab or newline.
.sp
.LP
Variables can be created, displayed, or destroyed using the \fBset\fR and
\fBunset\fR commands. Some variables are maintained or used by the shell. For
instance, the \fBargv\fR variable contains an image of the shell's argument
list. Of the variables used by the shell, a number are toggles; the shell does
not care what their value is, only whether they are set or not.
.sp
.LP
Numerical values can be operated on as numbers (as with the \fB@\fR built-in
command). With numeric operations, an empty value is considered to be zero. The
second and subsequent words of multiword values are ignored. For instance, when
the \fBverbose\fR variable is set to any value (including an empty value),
command input is echoed on the terminal.
.sp
.LP
Command and filename substitution is subsequently applied to the words that
result from the variable substitution, except when suppressed by double-quotes,
when \fBnoglob\fR is set (suppressing filename substitution), or when the
reference is quoted with the \fB:q\fR modifier. Within double-quotes, a
reference is expanded to form (a portion of) a quoted string; multiword values
are expanded to a string with embedded space characters. When the \fB:q\fR
modifier is applied to the reference, it is expanded to a list of
space-separated words, each of which is quoted to prevent subsequent command or
filename substitutions.
.sp
.LP
Except as noted below, it is an error to refer to a variable that is not set.
.sp
.ne 2
.na
\fB\fB$\fR\fIvar\fR\fR
.ad
.br
.na
\fB\fB${\fR\fIvar\fR\fB}\fR\fR
.ad
.RS 17n
These are replaced by words from the value of \fIvar\fR, each separated by a
space character. If \fIvar\fR is an environment variable, its value is returned
(but `\fB:\fR' modifiers and the other forms given below are not available).
.RE

.sp
.ne 2
.na
\fB\fB$\fR\fIvar\fR\fB[\fR\fIindex\fR\fB]\fR\fR
.ad
.br
.na
\fB\fB${\fR\fIvar\fR\fB[\fR\fIindex\fR\fB]}\fR\fR
.ad
.RS 17n
These select only the indicated words from the value of \fIvar\fR. Variable
substitution is applied to \fIindex\fR\|, which can consist of (or result in) a
either single number, two numbers separated by a `\fB\(mi\fR\&', or an
asterisk. Words are indexed starting from 1; a `\fB*\fR' selects all words. If
the first number of a range is omitted (as with \fB$argv[\(mi2]\fR), it
defaults to 1. If the last number of a range is omitted (as with
\fB$argv[1\(mi]\fR), it defaults to \fB$#\fR\fIvar\fR (the word count). It is
not an error for a range to be empty if the second argument is omitted (or
within range).
.RE

.sp
.ne 2
.na
\fB\fB$#\fR\fIname\fR\fR
.ad
.br
.na
\fB\fB${#\fR\fIname\fR\fB}\fR\fR
.ad
.RS 17n
These give the number of words in the variable.
.RE

.sp
.ne 2
.na
\fB\fB$0\fR\fR
.ad
.RS 17n
This substitutes the name of the file from which command input is being read
except for setuid shell scripts. An error occurs if the name is not known.
.RE

.sp
.ne 2
.na
\fB\fB$\fR\fIn\fR\fR
.ad
.br
.na
\fB\fB${\fR\fIn\fR\fB}\fR\fR
.ad
.RS 17n
Equivalent to \fB$argv[\fR\fIn\fR\fB]\fR\fI\&.\fR
.RE

.sp
.ne 2
.na
\fB\fB$*\fR\fR
.ad
.RS 17n
Equivalent to \fB$argv[*]\fR.
.RE

.sp
.LP
The modifiers \fB:e\fR, \fB:h\fR, \fB:q\fR, \fB:r\fR, \fB:t\fR, and \fB:x\fR
can be applied (see \fBHistory\fR \fBSubstitution\fR), as can \fB:gh\fR,
\fB:gt\fR, and \fB:gr\fR. If \fB{\|}\fR (braces) are used, then the modifiers
must appear within the braces. The current implementation allows only one such
modifier per expansion.
.sp
.LP
The following references can not be modified with \fB:\fR modifiers.
.sp
.ne 2
.na
\fB\fB$?\fR\fIvar\fR\fR
.ad
.br
.na
\fB\fB${?\fR\fIvar\fR\fB}\fR\fR
.ad
.RS 11n
Substitutes the string 1 if \fIvar\fR is set or 0 if it is not set.
.RE

.sp
.ne 2
.na
\fB\fB$?0\fR\fR
.ad
.RS 11n
Substitutes 1 if the current input filename is known or 0 if it is not.
.RE

.sp
.ne 2
.na
\fB\fB$$\fR\fR
.ad
.RS 11n
Substitutes the process number of the (parent) shell.
.RE

.sp
.ne 2
.na
\fB\fB$<\fR\fR
.ad
.RS 11n
Substitutes a line from the standard input, with no further interpretation
thereafter. It can be used to read from the keyboard in a C shell script.
.RE

.SS "Command and Filename Substitutions"
.LP
Command and filename substitutions are applied selectively to the arguments of
built-in commands. Portions of expressions that are not evaluated are not
expanded. For non-built-in commands, filename expansion of the command name is
done separately from that of the argument list; expansion occurs in a subshell,
after I/O redirection is performed.
.SS "Command Substitution"
.LP
A command enclosed by backquotes (\|\fB`\fR\|.\|.\|.\|\fB`\fR\|) is performed
by a subshell. Its standard output is broken into separate words at each space
character, tab and newline; null words are discarded. This text replaces the
backquoted string on the current command line. Within double-quotes, only
newline characters force new words; space and tab characters are preserved.
However, a final newline is ignored. It is therefore possible for a command
substitution to yield a partial word.
.SS "Filename Substitution"
.LP
Unquoted words containing any of the characters \fB*\fR, \fB?\fR, \fB[\fR or
\fB{\fR, or that begin with ~, are expanded (also known as \fIglobbing\fR) to
an alphabetically sorted list of filenames, as follows:
.sp
.ne 2
.na
\fB*\fR
.ad
.RS 24n
Match any (zero or more) characters.
.RE

.sp
.ne 2
.na
\fB?\fR
.ad
.RS 24n
Match any single character.
.RE

.sp
.ne 2
.na
\fB\fB[\fR.\|.\|.\fB]\fR\fR
.ad
.RS 24n
Match any single character in the enclosed list(s) or range(s). A list is a
string of characters. A range is two characters separated by a dash
(\fB\(mi\fR), and includes all the characters in between in the \fBASCII\fR
collating sequence (see \fBascii\fR(5)).
.RE

.sp
.ne 2
.na
\fB{\fIstr\fR\fB,\fR \fIstr\fR\fB,\fR .\|.\|. \fB}\fR\fR
.ad
.RS 24n
Expand to each string (or filename-matching pattern) in the comma-separated
list. Unlike the pattern-matching expressions above, the expansion of this
construct is not sorted. For instance, \fB{b,a}\fR expands to `\fBb\fR'
`\fBa\fR', (not `\fBa\fR' `\fBb\fR'). As special cases, the characters \fB{\fR
and \fB}\fR, along with the string \fB{\|}\fR, are passed undisturbed.
.RE

.sp
.ne 2
.na
\fB~[\fIuser\fR]\fR
.ad
.RS 24n
Your home directory, as indicated by the value of the variable \fBhome\fR, or
that of \fIuser\fR, as indicated by the password entry for \fIuser\fR.
.RE

.sp
.LP
Only the patterns \fB*\fR, \fB?\fR and \fB[\fR.\|.\|.\fB]\fR imply pattern
matching; an error results if no filename matches a pattern that contains them.
The `\fB\&.\fR' (dot character), when it is the first character in a filename
or pathname component, must be matched explicitly. The \fB/\fR (slash) must
also be matched explicitly.
.SS "Expressions and Operators"
.LP
A number of C shell built-in commands accept expressions, in which the
operators are similar to those of C and have the same precedence. These
expressions typically appear in the \fB@\fR, \fBexit\fR, \fBif\fR, \fBset\fR
and \fBwhile\fR commands, and are often used to regulate the flow of control
for executing commands. Components of an expression are separated by white
space.
.sp
.LP
Null or missing values are considered \fB0\fR. The result of all expressions is
a string, which can represent decimal numbers.
.sp
.LP
The following C shell operators are grouped in order of precedence:
.sp
.ne 2
.na
\fB\fB(\|\fR.\|.\|.\|\fB\|)\fR\fR
.ad
.RS 19n
grouping
.RE

.sp
.ne 2
.na
\fB>\fB~\fR\fR
.ad
.RS 19n
one's complement
.RE

.sp
.ne 2
.na
\fB\fB!\fR\fR
.ad
.RS 19n
logical negation
.RE

.sp
.ne 2
.na
\fB\fB* / %\fR\fR
.ad
.RS 19n
multiplication, division, remainder. These are right associative, which can
lead to unexpected results. Combinations should be grouped explicitly with
parentheses.
.RE

.sp
.ne 2
.na
\fB\fB+ \(mi\fR\fR
.ad
.RS 19n
addition, subtraction (also right associative)
.RE

.sp
.ne 2
.na
\fB\fB<< >>\fR\fR
.ad
.RS 19n
bitwise shift left, bitwise shift right
.RE

.sp
.ne 2
.na
\fB\fB< > <= >=\fR\fR
.ad
.RS 19n
less than, greater than, less than or equal to, greater than or equal to
.RE

.sp
.ne 2
.na
\fB\fB=\|= != =~ !~\fR\fR
.ad
.RS 19n
equal to, not equal to, filename-substitution pattern match (described below),
filename-substitution pattern mismatch
.RE

.sp
.ne 2
.na
\fB\fB&\fR\fR
.ad
.RS 19n
bitwise AND
.RE

.sp
.ne 2
.na
\fB\fB^\fR\fR
.ad
.RS 19n
bitwise XOR (exclusive or)
.RE

.sp
.ne 2
.na
\fB\fB|\fR\fR
.ad
.RS 19n
bitwise inclusive OR
.RE

.sp
.ne 2
.na
\fB\fB&&\fR\fR
.ad
.RS 19n
logical AND
.RE

.sp
.ne 2
.na
\fB\fB|\|\||\fR\fR
.ad
.RS 19n
logical OR
.RE

.sp
.LP
The operators: \fB==\fR, \fB!=\fR, \fB=~\fR, and \fB!~\fR compare their
arguments as strings; other operators use numbers. The operators \fB=~\fR and
\fB!~\fR each check whether or not a string to the left matches a filename
substitution pattern on the right. This reduces the need for \fBswitch\fR
statements when pattern-matching between strings is all that is required.
.sp
.LP
Also available are file inquiries:
.sp
.ne 2
.na
\fB\fB-r\fR\fIfilename\fR\fR
.ad
.RS 15n
Return true, or 1 if the user has read access. Otherwise it returns false, or
0.
.RE

.sp
.ne 2
.na
\fB\fB-w\fR\fIfilename\fR\fR
.ad
.RS 15n
True if the user has write access.
.RE

.sp
.ne 2
.na
\fB\fB-x\fR\fIfilename\fR\fR
.ad
.RS 15n
True if the user has execute permission (or search permission on a directory).
.RE

.sp
.ne 2
.na
\fB\fB-e\fR\fIfilename\fR\fR
.ad
.RS 15n
True if \fIfilename\fR exists.
.RE

.sp
.ne 2
.na
\fB\fB-o\fR\fIfilename\fR\fR
.ad
.RS 15n
True if the user owns \fIfilename\fR.
.RE

.sp
.ne 2
.na
\fB\fB-z\fR \fIfilename\fR\fR
.ad
.RS 15n
True if \fIfilename\fR is of zero length (empty).
.RE

.sp
.ne 2
.na
\fB\fB-f\fR\fIfilename\fR\fR
.ad
.RS 15n
True if \fIfilename\fR is a plain file.
.RE

.sp
.ne 2
.na
\fB\fB-d\fR\fIfilename\fR\fR
.ad
.RS 15n
True if \fIfilename\fR is a directory.
.RE

.sp
.LP
If \fIfilename\fR does not exist or is inaccessible, then all inquiries return
false.
.sp
.LP
An inquiry as to the success of a command is also available:
.sp
.ne 2
.na
\fB\fB{\fR \fIcommand\fR\fB}\fR\fR
.ad
.RS 14n
If \fIcommand\fR runs successfully, the expression evaluates to true, 1.
Otherwise, it evaluates to false, 0. \fBNote:\fR Conversely, \fIcommand\fR
itself typically returns 0 when it runs successfully, or some other value if it
encounters a problem. If you want to get at the status directly, use the value
of the \fBstatus\fR variable rather than this expression.
.RE

.SS "Control Flow"
.LP
The shell contains a number of commands to regulate the flow of control in
scripts and within limits, from the terminal. These commands operate by forcing
the shell either to reread input (to \fIloop\fR), or to skip input under
certain conditions (to \fIbranch\fR).
.sp
.LP
Each occurrence of a \fBforeach\fR, \fBswitch\fR, \fBwhile\fR,
\fBif\fR.\|.\|.\fBthen\fR and \fBelse\fR built-in command must appear as the
first word on its own input line.
.sp
.LP
If the shell's input is not seekable and a loop is being read, that input is
buffered. The shell performs seeks within the internal buffer to accomplish the
rereading implied by the loop. (To the extent that this allows, backward
\fBgoto\fR commands succeeds on nonseekable inputs.)
.SS "Command Execution"
.LP
If the command is a C shell built-in command, the shell executes it directly.
Otherwise, the shell searches for a file by that name with execute access. If
the command name contains a \fB/\fR, the shell takes it as a pathname, and
searches for it. If the command name does not contain a \fB/\fR, the shell
attempts to resolve it to a pathname, searching each directory in the
\fBpath\fR variable for the command. To speed the search, the shell uses its
hash table (see the \fBrehash\fR built-in command) to eliminate directories
that have no applicable files. This hashing can be disabled with the \fB-c\fR
or \fB-t\fR, options, or the \fBunhash\fR built-in command.
.sp
.LP
As a special case, if there is no \fB/\fR in the name of the script and there
is an alias for the word \fBshell\fR, the expansion of the \fBshell\fR alias is
prepended (without modification) to the command line. The system attempts to
execute the first word of this special (late-occurring) alias, which should be
a full pathname. Remaining words of the alias's definition, along with the text
of the input line, are treated as arguments.
.sp
.LP
When a pathname is found that has proper execute permissions, the shell forks a
new process and passes it, along with its arguments, to the kernel using the
\fBexecve\fR(\|) system call (see \fBexec\fR(2)). The kernel then attempts to
overlay the new process with the desired program. If the file is an executable
binary (in \fBa.out\fR(4) format) the kernel succeeds and begins executing the
new process. If the file is a text file and the first line begins with
\fB#!\fR, the next word is taken to be the pathname of a shell (or command) to
interpret that script. Subsequent words on the first line are taken as options
for that shell. The kernel invokes (overlays) the indicated shell, using the
name of the script as an argument.
.sp
.LP
If neither of the above conditions holds, the kernel cannot overlay the file
and the \fBexecve\fR(\|) call fails (see \fBexec\fR(2)). The C shell then
attempts to execute the file by spawning a new shell, as follows:
.RS +4
.TP
.ie t \(bu
.el o
If the first character of the file is a \fB#\fR, a C shell is invoked.
.RE
.RS +4
.TP
.ie t \(bu
.el o
Otherwise, a Bourne shell is invoked.
.RE
.SS "Signal Handling"
.LP
The shell normally ignores \fBQUIT\fR signals. Background jobs are immune to
signals generated from the keyboard, including hangups (\fBHUP\fR). Other
signals have the values that the C shell inherited from its environment. The
shell's handling of interrupt and terminate signals within scripts can be
controlled by the \fBonintr\fR built-in command. Login shells catch the
\fBTERM\fR signal. Otherwise, this signal is passed on to child processes. In
no case are interrupts allowed when a login shell is reading the
\fB\&.logout\fR file.
.SS "Job Control"
.LP
The shell associates a numbered \fIjob\fR with each command sequence to keep
track of those commands that are running in the background or have been stopped
with \fBTSTP\fR signals (typically Control-z). When a command or command
sequence (semicolon separated list) is started in the background using the
\fB&\fR metacharacter, the shell displays a line with the job number in
brackets and a list of associated process numbers:
.sp
.in +2
.nf
[1] 1234
.fi
.in -2
.sp

.sp
.LP
To see the current list of jobs, use the \fBjobs\fR built-in command. The job
most recently stopped (or put into the background if none are stopped) is
referred to as the \fIcurrent\fR job and is indicated with a `\fB+\fR'. The
previous job is indicated with a `\fB\(mi\fR\&'. When the current job is
terminated or moved to the foreground, this job takes its place (becomes the
new current job).
.sp
.LP
To manipulate jobs, refer to the \fBbg\fR, \fBfg\fR, \fBkill\fR, \fBstop\fR,
and \fB%\fR built-in commands.
.sp
.LP
A reference to a job begins with a `\fB%\fR'. By itself, the percent-sign
refers to the current job.
.sp
.ne 2
.na
\fB\fB%\fR \fB%+\fR \fB%%\fR\fR
.ad
.RS 12n
The current job.
.RE

.sp
.ne 2
.na
\fB\fB%\(mi\fR\fR
.ad
.RS 12n
The previous job.
.RE

.sp
.ne 2
.na
\fB\fB%\fR\fIj\fR\fR
.ad
.RS 12n
Refer to job \fIj\fR as in: `\fBkill\fR \fB-9\fR \fB%\fR\fIj\fR'. \fIj\fR can
be a job number, or a string that uniquely specifies the command line by which
it was started; `\fBfg %vi\fR' might bring a stopped \fBvi\fR job to the
foreground, for instance.
.RE

.sp
.ne 2
.na
\fB\fB%?\fR\fIstring\fR\fR
.ad
.RS 12n
Specify the job for which the command line uniquely contains \fIstring\fR.
.RE

.sp
.LP
A job running in the background stops when it attempts to read from the
terminal. Background jobs can normally produce output, but this can be
suppressed using the `\fBstty tostop\fR' command.
.SS "Status Reporting"
.LP
While running interactively, the shell tracks the status of each job and
reports whenever the job finishes or becomes blocked. It normally displays a
message to this effect as it issues a prompt, in order to avoid disturbing the
appearance of your input. When set, the \fBnotify\fR variable indicates that
the shell is to report status changes immediately. By default, the \fBnotify\fR
command marks the current process; after starting a background job, type
\fBnotify\fR to mark it.
.SS "Commands"
.LP
Built-in commands are executed within the C shell. If a built-in command occurs
as any component of a pipeline except the last, it is executed in a subshell.
.sp
.ne 2
.na
\fB\fB:\fR\fR
.ad
.RS 26n
Null command. This command is interpreted, but performs no action.
.RE

.sp
.ne 2
.na
\fB\fBalias\fR [ \fIname\fR [ \fIdef\fR ] ]\fR
.ad
.RS 26n
Assign \fIdef\fR to the alias \fIname\fR. \fIdef\fR is a list of words that can
contain escaped history-substitution metasyntax. \fIname\fR is not allowed to
be \fBalias\fR or \fBunalias\fR. If \fIdef\fR is omitted, the current
definition for the alias \fIname\fR is displayed. If both \fIname\fR and
\fIdef\fR are omitted, all aliases are displayed with their definitions.
.RE

.sp
.ne 2
.na
\fB\fBbg\fR [ \fB%\fR\fIjob .\|.\|.\fR ]\fR
.ad
.RS 26n
Run the current or specified jobs in the background.
.RE

.sp
.ne 2
.na
\fB\fBbreak\fR\fR
.ad
.RS 26n
Resume execution after the \fBend\fR of the nearest enclosing \fBforeach\fR or
\fBwhile\fR loop. The remaining commands on the current line are executed. This
allows multilevel breaks to be written as a list of \fBbreak\fR commands, all
on one line.
.RE

.sp
.ne 2
.na
\fB\fBbreaksw\fR\fR
.ad
.RS 26n
Break from a \fBswitch\fR, resuming after the \fBendsw\fR.
.RE

.sp
.ne 2
.na
\fB\fBcase\fR \fIlabel\fR\fB:\fR\fR
.ad
.RS 26n
A label in a \fBswitch\fR statement.
.RE

.sp
.ne 2
.na
\fB\fBcd\fR [\fIdir\fR ]\fR
.ad
.br
.na
\fB\fBchdir\fR [\fIdir\fR ]\fR
.ad
.RS 26n
Change the shell's working directory to directory \fIdir\fR. If no argument is
given, change to the home directory of the user. If \fIdir\fR is a relative
pathname not found in the current directory, check for it in those directories
listed in the \fBcdpath\fR variable. If \fIdir\fR is the name of a shell
variable whose value starts with a \fB/\fR, change to the directory named by
that value.
.RE

.sp
.ne 2
.na
\fB\fBcontinue\fR\fR
.ad
.RS 26n
Continue execution of the next iteration of the nearest enclosing \fBwhile\fR
or \fBforeach\fR loop.
.RE

.sp
.ne 2
.na
\fB\fBdefault:\fR\fR
.ad
.RS 26n
Labels the default case in a \fBswitch\fR statement. The default should come
after all \fBcase\fR labels. Any remaining commands on the command line are
first executed.
.RE

.sp
.ne 2
.na
\fB\fBdirs\fR [\fB-l\fR]\fR
.ad
.RS 26n
Print the directory stack, most recent to the left. The first directory shown
is the current directory. With the \fB-l\fR argument, produce an unabbreviated
printout; use of the ~ notation is suppressed.
.RE

.sp
.ne 2
.na
\fB\fBecho\fR [\fB-n\fR] \fIlist\fR\fR
.ad
.RS 26n
The words in \fIlist\fR are written to the shell's standard output, separated
by space characters. The output is terminated with a newline unless the
\fB-n\fR option is used. \fBcsh\fR, by default, invokes its built-in
\fBecho\fR, if \fBecho\fR is called without the full pathname of a Unix
command, regardless of the configuration of your \fBPATH\fR (see
\fBecho\fR(1)).
.RE

.sp
.ne 2
.na
\fB\fBeval\fR \fIargument\fR\fB\|.\|.\|.\fR\fR
.ad
.RS 26n
Reads the arguments as input to the shell and executes the resulting
command(s). This is usually used to execute commands generated as the result of
command or variable substitution. See \fBtset\fR(1B) for an example of how to
use \fBeval\fR.
.RE

.sp
.ne 2
.na
\fB\fBexec\fR \fIcommand\fR\fR
.ad
.RS 26n
Execute \fIcommand\fR in place of the current shell, which terminates.
.RE

.sp
.ne 2
.na
\fB\fBexit\fR [\fB(\fR\fIexpr\fR\fB)\fR]\fR
.ad
.RS 26n
The calling shell or shell script exits, either with the value of the status
variable or with the value specified by the expression \fIexpr\fR.
.RE

.sp
.ne 2
.na
\fB\fBfg\fR [\fB%\fR\fIjob\fR ]\fR
.ad
.RS 26n
Bring the current or specified \fIjob\fR into the foreground.
.RE

.sp
.ne 2
.na
\fB\fBforeach\fR \fIvar\fR\fB(\fR\fIwordlist\fR\fB)\fR\fR
.ad
.br
.na
\fB\&.\|.\|.\fR
.ad
.br
.na
\fB\fBend\fR\fR
.ad
.RS 26n
The variable \fIvar\fR is successively set to each member of \fIwordlist\fR.
The sequence of commands between this command and the matching \fBend\fR is
executed for each new value of \fIvar\fR. Both \fBforeach\fR and \fBend\fR must
appear alone on separate lines.
.sp
The built-in command \fBcontinue\fR can be used to terminate the execution of
the current iteration of the loop and the built-in command \fBbreak\fR can be
used to terminate execution of the \fBforeach\fR command. When this command is
read from the terminal, the loop is read once prompting with \fB?\fR before any
statements in the loop are executed.
.RE

.sp
.ne 2
.na
\fB\fBglob\fR \fIwordlist\fR\fR
.ad
.sp .6
.RS 4n
Perform filename expansion on \fIwordlist\fR. Like \fBecho\fR, but no \fB\e\fR
escapes are recognized. Words are delimited by \fINULL\fR characters in the
output.
.RE

.sp
.ne 2
.na
\fB\fBgoto\fR\fIlabel\fR\fR
.ad
.sp .6
.RS 4n
The specified \fIlabel\fR is a filename and a command expanded to yield a
label. The shell rewinds its input as much as possible and searches for a line
of the form \fIlabel\fR\fB:\fR possibly preceded by space or tab characters.
Execution continues after the indicated line. It is an error to jump to a label
that occurs between a \fBwhile\fR or \fBfor\fR built-in command and its
corresponding \fBend\fR.
.RE

.sp
.ne 2
.na
\fB\fBhashstat\fR\fR
.ad
.sp .6
.RS 4n
Print a statistics line indicating how effective the internal hash table for
the \fIpath\fR variable has been at locating commands (and avoiding
\fBexec\fRs). An \fBexec\fR is attempted for each component of the \fIpath\fR
where the hash function indicates a possible hit and in each component that
does not begin with a `\fB/\fR'. These statistics only reflect the
effectiveness of the \fIpath\fR variable, not the \fIcdpath\fR variable.
.RE

.sp
.ne 2
.na
\fB\fBhistory\fR [\fB-hr\fR] [\fIn\fR]\fR
.ad
.sp .6
.RS 4n
Display the history list; if \fIn\fR is given, display only the \fIn\fR most
recent events.
.sp
.ne 2
.na
\fB\fB-r\fR\fR
.ad
.RS 6n
Reverse the order of printout to be most recent first rather than oldest first.
.RE

.sp
.ne 2
.na
\fB\fB-h\fR\fR
.ad
.RS 6n
Display the history list without leading numbers. This is used to produce files
suitable for sourcing using the \fB-h\fR option to \fIsource\fR.
.RE

.RE

.sp
.ne 2
.na
\fB\fBif (\fR\fIexpr\fR \fB)\fR\fIcommand\fR\fR
.ad
.sp .6
.RS 4n
If the specified expression evaluates to true, the single \fIcommand\fR with
arguments is executed. Variable substitution on \fIcommand\fR happens early, at
the same time it does for the rest of the \fBif\fR command. \fIcommand\fR must
be a simple command, not a pipeline, a command list, or a parenthesized command
list. \fBNote:\fR I/O redirection occurs even if \fIexpr\fR is false, when
\fIcommand\fR is \fInot\fR executed (this is a bug).
.RE

.sp
.ne 2
.na
\fB\fBif (\fR\fBexpr\fR\fB) then\fR\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
\fB\fBelse if (\fR\fIexpr2\fR\fB) then\fR\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
\fB\fBelse\fR\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
\fB\fBendif\fR\fR
.ad
.sp .6
.RS 4n
If \fIexpr\fR is true, commands up to the first \fBelse\fR are executed.
Otherwise, if \fIexpr2\fR is true, the commands between the \fBelse if\fR and
the second \fBelse\fR are executed. Otherwise, commands between the \fBelse\fR
and the \fBendif\fR are executed. Any number of \fBelse if\fR pairs are
allowed, but only one \fBelse\fR. Only one \fBendif\fR is needed, but it is
required. The words \fBelse\fR and \fBendif\fR must be the first nonwhite
characters on a line. The \fBif\fR must appear alone on its input line or after
an \fBelse\fR.
.RE

.sp
.ne 2
.na
\fB\fBjobs\fR [\fB-l\fR]\fR
.ad
.sp .6
.RS 4n
List the active jobs under job control.
.sp
.ne 2
.na
\fB\fB-l\fR\fR
.ad
.RS 6n
List process \fBID\fRs, in addition to the normal information.
.RE

.RE

.sp
.ne 2
.na
\fB\fBkill\fR [\fIsig\fR ] [ \fIpid\fR ] [ \fB%\fR\fB\fIjob\fR ] .\|.\|.\fR\fR
.ad
.br
.na
\fB\fBkill\fR \fB-l\fR\fR
.ad
.sp .6
.RS 4n
Send the \fBTERM\fR (terminate) signal, by default, or the signal specified, to
the specified process ID, the \fIjob\fR indicated, or the current \fIjob\fR.
Signals are either given by number or by name. There is no default. Typing
\fBkill\fR does not send a signal to the current job. If the signal being sent
is \fBTERM\fR (terminate) or \fBHUP\fR (hangup), then the job or process is
sent a \fBCONT\fR (continue) signal as well.
.sp
.ne 2
.na
\fB\fB-l\fR\fR
.ad
.RS 6n
List the signal names that can be sent.
.RE

.RE

.sp
.ne 2
.na
\fB\fBlimit\fR [\fB-h\fR] [\fIresource\fR [\fImax-use\fR ] ]\fR
.ad
.sp .6
.RS 4n
Limit the consumption by the current process or any process it spawns, each not
to exceed \fImax-use\fR on the specified \fIresource\fR. The string
\fBunlimited\fR requests that the current limit, if any, be removed. If
\fImax-use\fR is omitted, print the current limit. If \fIresource\fR is
omitted, display all limits. Run the \fBsysdef\fR(1M) command to display
maximum limits for certain resources in your system (although it does not
report stack size). The values reported are in hexadecimal, but can be
translated into decimal numbers using the \fBbc\fR(1) command.
.sp
.ne 2
.na
\fB\fB-h\fR\fR
.ad
.RS 6n
Use hard limits instead of the current limits. Hard limits impose a ceiling on
the values of the current limits. Only the privileged user can raise the hard
limits.
.RE

\fIresource\fR is one of:
.sp
.ne 2
.na
\fB\fBcputime\fR\fR
.ad
.RS 23n
Maximum \fBCPU\fR seconds per process.
.RE

.sp
.ne 2
.na
\fB\fBfilesize\fR\fR
.ad
.RS 23n
Largest single file allowed. Limited to the size of the filesystem. (See
\fBdf\fR(1M)).
.RE

.sp
.ne 2
.na
\fB\fBdatasize\fR (heapsize)\fR
.ad
.RS 23n
Maximum data size (including stack) for the process. This is the size of your
virtual memory See \fBswap\fR(1M).
.RE

.sp
.ne 2
.na
\fB\fBstacksize\fR\fR
.ad
.RS 23n
Maximum stack size for the process. The default stack size is 2^64 bytes. You
can use \fBlimit\fR(1) to change this default within a shell.
.RE

.sp
.ne 2
.na
\fB\fBcoredumpsize\fR\fR
.ad
.RS 23n
Maximum size of a core dump (file). This limited to the size of the filesystem.
.RE

.sp
.ne 2
.na
\fB\fBdescriptors\fR\fR
.ad
.RS 23n
Maximum number of file descriptors. Run \fBsysdef()\fR.
.RE

.sp
.ne 2
.na
\fB\fBmemorysize\fR\fR
.ad
.RS 23n
Maximum size of virtual memory.
.RE

\fImax-use\fR is a number, with an optional scaling factor, as follows:
.sp
.ne 2
.na
\fB\fIn\fR\fBh\fR\fR
.ad
.RS 9n
Hours (for \fBcputime\fR).
.RE

.sp
.ne 2
.na
\fB\fIn\fR\fBk\fR\fR
.ad
.RS 9n
\fIn\fR kilobytes. This is the default for all but \fBcputime\fR.
.RE

.sp
.ne 2
.na
\fB\fIn\fR\fBm\fR\fR
.ad
.RS 9n
\fIn\fR megabytes or minutes (for \fBcputime\fR).
.RE

.sp
.ne 2
.na
\fB\fImm\fR\fB:\fR\fIss\fR\fR
.ad
.RS 9n
Minutes and seconds (for \fBcputime\fR).
.RE

Example of limit: To limit the size of a core file dump to \fB0\fR Megabytes,
type the following:
.sp
.in +2
.nf
\fBlimit coredumpsize 0M\fR
.fi
.in -2
.sp

.RE

.sp
.ne 2
.na
\fB\fBlogin\fR [\fIusername\fR\|| \fB-p\fR ]\fR
.ad
.sp .6
.RS 4n
Terminate a login shell and invoke \fBlogin\fR(1). The \fB\&.logout\fR file is
not processed. If \fIusername\fR is omitted, \fBlogin\fR prompts for the name
of a user.
.sp
.ne 2
.na
\fB\fB-p\fR\fR
.ad
.RS 6n
Preserve the current environment (variables).
.RE

.RE

.sp
.ne 2
.na
\fB\fBlogout\fR\fR
.ad
.sp .6
.RS 4n
Terminate a login shell.
.RE

.sp
.ne 2
.na
\fB\fBnice\fR [\fB+\fR\fIn\fR \||\fB-\fR\fIn\fR ] [\fIcommand\fR ]\fR
.ad
.sp .6
.RS 4n
Increment the process priority value for the shell or for \fIcommand\fR by
\fIn\fR. The higher the priority value, the lower the priority of a process,
and the slower it runs. When given, \fIcommand\fR is always run in a subshell,
and the restrictions placed on commands in simple \fBif\fR commands apply. If
\fIcommand\fR is omitted, \fBnice\fR increments the value for the current
shell. If no increment is specified, \fBnice\fR sets the process priority value
to 4. The range of process priority values is from \(mi20 to 20. Values of
\fIn\fR outside this range set the value to the lower, or to the higher
boundary, respectively.
.sp
.ne 2
.na
\fB\fB+\fR\fIn\fR\fR
.ad
.RS 6n
Increment the process priority value by \fIn\fR.
.RE

.sp
.ne 2
.na
\fB\fB-\fR\fIn\fR\fR
.ad
.RS 6n
Decrement by \fIn\fR. This argument can be used only by the privileged user.
.RE

.RE

.sp
.ne 2
.na
\fB\fBnohup\fR [\fIcommand\fR ]\fR
.ad
.sp .6
.RS 4n
Run \fIcommand\fR with \fBHUP\fRs ignored. With no arguments, ignore \fBHUP\fRs
throughout the remainder of a script. When given, \fIcommand\fR is always run
in a subshell, and the restrictions placed on commands in simple \fBif\fR
statements apply. All processes detached with \fB&\fR are effectively
\fBnohup\fR'd.
.RE

.sp
.ne 2
.na
\fB\fBnotify\fR [\fB%\fR\fIjob\fR] .\|.\|.\fR
.ad
.sp .6
.RS 4n
Notify the user asynchronously when the status of the current job or specified
jobs changes.
.RE

.sp
.ne 2
.na
\fB\fBonintr\fR [\fB\(mi\fR| \fIlabel\fR]\fR
.ad
.sp .6
.RS 4n
Control the action of the shell on interrupts. With no arguments, \fBonintr\fR
restores the default action of the shell on interrupts. (The shell terminates
shell scripts and returns to the terminal command input level). With the
\fB\(mi\fR argument, the shell ignores all interrupts. With a \fIlabel\fR
argument, the shell executes a \fBgoto\fR \fIlabel\fR when an interrupt is
received or a child process terminates because it was interrupted.
.RE

.sp
.ne 2
.na
\fB\fBpopd\fR [\fB+\fR\fIn\fR ]\fR
.ad
.sp .6
.RS 4n
Pop the directory stack and \fBcd\fR to the new top directory. The elements of
the directory stack are numbered from 0 starting at the top.
.sp
.ne 2
.na
\fB\fB+\fR\fIn\fR\fR
.ad
.RS 6n
Discard the \fIn\fR'th entry in the stack.
.RE

.RE

.sp
.ne 2
.na
\fB\fBpushd\fR [\fB+\fR\fIn\fR |\fIdir\fR]\fR
.ad
.sp .6
.RS 4n
Push a directory onto the directory stack. With no arguments, exchange the top
two elements.
.sp
.ne 2
.na
\fB\fB+\fR\fIn\fR\fR
.ad
.RS 7n
Rotate the \fIn\fR'th entry to the top of the stack and \fBcd\fR to it.
.RE

.sp
.ne 2
.na
\fB\fIdir\fR\fR
.ad
.RS 7n
Push the current working directory onto the stack and change to \fIdir\fR.
.RE

.RE

.sp
.ne 2
.na
\fB\fBrehash\fR\fR
.ad
.sp .6
.RS 4n
Recompute the internal hash table of the contents of directories listed in the
\fIpath\fR variable to account for new commands added. Recompute the internal
hash table of the contents of directories listed in the \fIcdpath\fR variable
to account for new directories added.
.RE

.sp
.ne 2
.na
\fB\fBrepeat\fR \fIcount command\fR\fR
.ad
.sp .6
.RS 4n
Repeat \fIcommand count\fR times. \fIcommand\fR is subject to the same
restrictions as with the one-line \fBif\fR statement.
.RE

.sp
.ne 2
.na
\fB\fBset\fR [\fIvar\fR [\fB=\fR \fIvalue\fR ] ]\fR
.ad
.br
.na
\fB\fBset\fR \fIvar\fR\fB[\fR\fIn\fR\fB] =\fR \fIword\fR\fR
.ad
.sp .6
.RS 4n
With no arguments, \fBset\fR displays the values of all shell variables.
Multiword values are displayed as a parenthesized list. With the \fIvar\fR
argument alone, \fBset\fR assigns an empty (null) value to the variable
\fIvar\fR. With arguments of the form \fIvar\fR \fB=\fR \fIvalue\fR \fBset\fR
assigns \fIvalue\fR to \fIvar\fR, where \fIvalue\fR is one of:
.sp
.ne 2
.na
\fB\fIword\fR\fR
.ad
.RS 14n
A single word (or quoted string).
.RE

.sp
.ne 2
.na
\fB\fB(\fR\fIwordlist\fR\fB)\fR\fR
.ad
.RS 14n
A space-separated list of words enclosed in parentheses.
.RE

Values are command and filename expanded before being assigned. The form
\fBset\fR\fIvar\fR\fB[\fR\fIn\fR\fB] =\fR \fIword\fR replaces the \fIn\fR'th
word in a multiword value with \fIword\fR.
.RE

.sp
.ne 2
.na
\fB\fBsetenv\fR [\fIVAR\fR [\fIword\fR ] ]\fR
.ad
.sp .6
.RS 4n
With no arguments, \fBsetenv\fR displays all environment variables. With the
\fIVAR\fR argument, \fBsetenv\fR sets the environment variable
\fB\fR\fIVAR\fR\fB \fR to have an empty (null) value. (By convention,
environment variables are normally given upper-case names.) With both \fIVAR\fR
and \fIword\fR arguments, \fBsetenv\fR sets the environment variable \fBNAME\fR
to the value \fIword\fR, which must be either a single word or a quoted string.
The most commonly used environment variables, \fBUSER\fR, \fBTERM\fR, and
\fBPATH\fR, are automatically imported to and exported from the \fBcsh\fR
variables \fBuser\fR, \fBterm\fR, and \fBpath\fR. There is no need to use
\fBsetenv\fR for these. In addition, the shell sets the \fBPWD\fR environment
variable from the \fBcsh\fR variable \fBcwd\fR whenever the latter changes.
.sp
The environment variables \fBLC_CTYPE\fR, \fBLC_MESSAGES\fR, \fBLC_TIME\fR,
\fBLC_COLLATE\fR, \fBLC_NUMERIC\fR, and \fBLC_MONETARY\fR take immediate effect
when changed within the C shell.
.sp
If any of the \fBLC_*\fR variables (\fBLC_CTYPE\fR, \fBLC_MESSAGES\fR,
\fBLC_TIME\fR, \fBLC_COLLATE\fR, \fBLC_NUMERIC\fR, and \fBLC_MONETARY\fR) (see
\fBenviron\fR(5)) are not set in the environment, the operational behavior of
\fBcsh\fR for each corresponding locale category is determined by the value of
the \fBLANG\fR environment variable. If \fBLC_ALL\fR is set, its contents are
used to override both the \fBLANG\fR and the other \fBLC_*\fR variables. If
none of the above variables is set in the environment, the "C" (U.S. style)
locale determines how \fBcsh\fR behaves.
.sp
.ne 2
.na
\fB\fBLC_CTYPE\fR\fR
.ad
.RS 15n
Determines how \fBcsh\fR handles characters. When \fBLC_CTYPE\fR is set to a
valid value, \fBcsh\fR can display and handle text and filenames containing
valid characters for that locale.
.RE

.sp
.ne 2
.na
\fB\fBLC_MESSAGES\fR\fR
.ad
.RS 15n
Determines how diagnostic and informative messages are presented. This includes
the language and style of the messages and the correct form of affirmative and
negative responses. In the "C" locale, the messages are presented in the
default form found in the program itself (in most cases, U.S./English).
.RE

.sp
.ne 2
.na
\fB\fBLC_NUMERIC\fR\fR
.ad
.RS 15n
Determines the value of the radix character, decimal point, (\fB\&.\fR) in the
"C" locale) and thousand separator, empty string (\fB""\fR) in the "C" locale).
.RE

.RE

.sp
.ne 2
.na
\fB\fBshift\fR [\fIvariable\fR ]\fR
.ad
.sp .6
.RS 4n
The components of \fBargv\fR, or \fIvariable\fR, if supplied, are shifted to
the left, discarding the first component. It is an error for the variable not
to be set or to have a null value.
.RE

.sp
.ne 2
.na
\fB\fBsource\fR [\fB-h\fR] \fIname\fR\fR
.ad
.sp .6
.RS 4n
Reads commands from \fIname\fR. \fBsource\fR commands can be nested, but if
they are nested too deeply the shell can run out of file descriptors. An error
in a sourced file at any level terminates all nested \fBsource\fR commands.
.sp
.ne 2
.na
\fB\fB-h\fR\fR
.ad
.RS 6n
Place commands from the file \fIname\fR on the history list without executing
them.
.RE

.RE

.sp
.ne 2
.na
\fB\fBstop\fR \fB%\fR\fIjobid .\|.\|.\fR\fR
.ad
.sp .6
.RS 4n
Stop the current or specified background job.
.RE

.sp
.ne 2
.na
\fB\fBstop\fR \fIpid .\|.\|.\fR\fR
.ad
.sp .6
.RS 4n
Stop the specified process, \fIpid\fR. (see \fBps\fR(1)).
.RE

.sp
.ne 2
.na
\fB\fBsuspend\fR\fR
.ad
.sp .6
.RS 4n
Stop the shell in its tracks, much as if it had been sent a stop signal with
\fB^Z\fR. This is most often used to stop shells started by \fBsu\fR.
.RE

.sp
.ne 2
.na
\fB\fBswitch (\fR\fIstring\fR\fB)\fR\fR
.ad
.br
.na
\fB\fBcase\fR \fIlabel\fR\fB:\fR\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
\fB\fBbreaksw\fR\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
\fB\fBdefault:\fR\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
\fB\fBbreaksw\fR\fR
.ad
.br
.na
\fB\fBendsw\fR\fR
.ad
.sp .6
.RS 4n
Each \fIlabel\fR is successively matched, against the specified \fIstring\fR,
which is first command and filename expanded. The file metacharacters \fB*\fR,
\fB?\fR and \fB[\fR.\|.\|.\fB]\fR can be used in the case labels, which are
variable expanded. If none of the labels match before a "default" label is
found, execution begins after the default label. Each \fBcase\fR statement and
the \fBdefault\fR statement must appear at the beginning of a line. The command
\fBbreaksw\fR continues execution after the \fBendsw\fR. Otherwise control
falls through subsequent \fBcase\fR and \fBdefault\fR statements as with C. If
no label matches and there is no default, execution continues after the
\fBendsw\fR.
.RE

.sp
.ne 2
.na
\fB\fBtime\fR [\fIcommand\fR ]\fR
.ad
.sp .6
.RS 4n
With no argument, print a summary of time used by this C shell and its
children. With an optional \fIcommand\fR, execute \fIcommand\fR and print a
summary of the time it uses. As of this writing, the \fBtime\fR built-in
command does NOT compute the last 6 fields of output, rendering the output to
erroneously report the value \fB0\fR for these fields.
.sp
.in +2
.nf
example %\fBtime ls\fR \fB-R\fR
        9.0u 11.0s 3:32 10% 0+0k 0+0io 0pf+0w
.fi
.in -2
.sp

(See the \fBEnvironment Variables and Predefined Shell Variables\fR sub-section
on the \fBtime\fR variable.)
.RE

.sp
.ne 2
.na
\fB\fBumask\fR [\fIvalue\fR ]\fR
.ad
.sp .6
.RS 4n
Display the file creation mask. With \fIvalue\fR, set the file creation mask.
With \fIvalue\fR given in octal, the user can turn off any bits, but cannot
turn on bits to allow new permissions. Common values include 077, restricting
all permissions from everyone else; 002, giving complete access to the group,
and read (and directory search) access to others; or 022, giving read (and
directory search) but not write permission to the group and others.
.RE

.sp
.ne 2
.na
\fB\fBunalias\fR \fIpattern\fR\fR
.ad
.sp .6
.RS 4n
Discard aliases that match (filename substitution) \fIpattern\fR. All aliases
are removed by `\fBunalias *\fR'.
.RE

.sp
.ne 2
.na
\fB\fBunhash\fR\fR
.ad
.sp .6
.RS 4n
Disable the internal hash tables for the \fIpath\fR and \fIcdpath\fR variables.
.RE

.sp
.ne 2
.na
\fB\fBunlimit\fR [\fB-h\fR] [\fIresource\fR ]\fR
.ad
.sp .6
.RS 4n
Remove a limitation on \fIresource\fR. If no \fIresource\fR is specified, then
all resource limitations are removed. See the description of the \fBlimit\fR
command for the list of resource names.
.sp
.ne 2
.na
\fB\fB-h\fR\fR
.ad
.RS 6n
Remove corresponding hard limits. Only the privileged user can do this.
.RE

.RE

.sp
.ne 2
.na
\fB\fBunset\fR \fIpattern\fR\fR
.ad
.sp .6
.RS 4n
Remove variables whose names match (filename substitution) \fIpattern\fR. All
variables are removed by `\fBunset *\fR'; this has noticeably distasteful side
effects.
.RE

.sp
.ne 2
.na
\fB\fBunsetenv\fR \fIvariable\fR\fR
.ad
.sp .6
.RS 4n
Remove \fIvariable\fR from the environment. As with \fBunset\fR, pattern
matching is not performed.
.RE

.sp
.ne 2
.na
\fB\fBwait\fR\fR
.ad
.sp .6
.RS 4n
Wait for background jobs to finish (or for an interrupt) before prompting.
.RE

.sp
.ne 2
.na
\fB\fBwhile (\fR\fIexpr\fR\fB)\fR\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
\fB\fBend\fR\fR
.ad
.sp .6
.RS 4n
While \fIexpr\fR is true (evaluates to nonzero), repeat commands between the
\fBwhile\fR and the matching \fBend\fR statement. \fBbreak\fR and
\fBcontinue\fR can be used to terminate or continue the loop prematurely. The
\fBwhile\fR and \fBend\fR must appear alone on their input lines. If the
shell's input is a terminal, it prompts for commands with a question-mark until
the \fBend\fR command is entered and then performs the commands in the loop.
.RE

.sp
.ne 2
.na
\fB\fB%\fR [\fIjob\fR ] [\fB&\fR]\fR
.ad
.sp .6
.RS 4n
Bring the current or indicated \fIjob\fR to the foreground. With the ampersand,
continue running \fIjob\fR in the background.
.RE

.sp
.ne 2
.na
\fB\fB@\fR [\fIvar\fR \fB=\fR\fIexpr\fR]\fR
.ad
.br
.na
\fB\fB@\fR [\fIvar\fR\fB[\fR\fIn\fR\fB]\fR\fB=\fR\fIexpr\fR]\fR
.ad
.sp .6
.RS 4n
With no arguments, display the values for all shell variables. With arguments,
set the variable \fIvar\fR, or the \fIn\fR'th word in the value of \fIvar\fR,
to the value that \fIexpr\fR evaluates to. (If \fB[\fR\fIn\fR\fB]\fR is
supplied, both \fIvar\fR and its \fIn\fR'th component must already exist.)
.sp
If the expression contains the characters \fB>\fR, \fB<\fR, \fB&\fR, or
\fB|\fR, then at least this part of \fIexpr\fR must be placed within
parentheses.
.sp
The operators \fB*=\fR, \fB+=\fR, and so forth, are available as in C. The
space separating the name from the assignment operator is optional. Spaces are,
however, mandatory in separating components of \fIexpr\fR that would otherwise
be single words.
.sp
Special postfix operators, \fB+\|+\fR and \fB\(mi\|\(mi\fR, increment or
decrement \fIname\fR, respectively.
.RE

.SS "Environment Variables and Predefined Shell Variables"
.LP
Unlike the Bourne shell, the C shell maintains a distinction between
environment variables, which are automatically exported to processes it
invokes, and shell variables, which are not. Both types of variables are
treated similarly under variable substitution. The shell sets the variables
\fBargv\fR, \fBcwd\fR, \fBhome\fR, \fBpath\fR, \fBprompt\fR, \fBshell\fR, and
\fBstatus\fR upon initialization. The shell copies the environment variable
\fBUSER\fR into the shell variable \fBuser\fR, \fBTERM\fR into \fBterm\fR, and
\fBHOME\fR into \fBhome\fR, and copies each back into the respective
environment variable whenever the shell variables are reset. \fBPATH\fR and
\fBpath\fR are similarly handled. You need only set \fBpath\fR once in the
\fB\&.cshrc\fR or \fB\&.login\fR file. The environment variable \fBPWD\fR is
set from \fBcwd\fR whenever the latter changes. The following shell variables
have predefined meanings:
.sp
.ne 2
.na
\fB\fBargv\fR\fR
.ad
.RS 13n
Argument list. Contains the list of command line arguments supplied to the
current invocation of the shell. This variable determines the value of the
positional parameters \fB$1\fR, \fB$2\fR, and so on.
.RE

.sp
.ne 2
.na
\fB\fBcdpath\fR\fR
.ad
.RS 13n
Contains a list of directories to be searched by the \fBcd\fR, \fBchdir\fR, and
\fBpopd\fR commands, if the directory argument each accepts is not a
subdirectory of the current directory.
.RE

.sp
.ne 2
.na
\fB\fBcwd\fR\fR
.ad
.RS 13n
The full pathname of the current directory.
.RE

.sp
.ne 2
.na
\fB\fBecho\fR\fR
.ad
.RS 13n
Echo commands (after substitutions) just before execution.
.RE

.sp
.ne 2
.na
\fB\fBfignore\fR\fR
.ad
.RS 13n
A list of filename suffixes to ignore when attempting filename completion.
Typically the single word `\fB\&.o\fR'.
.RE

.sp
.ne 2
.na
\fB\fBfilec\fR\fR
.ad
.RS 13n
Enable filename completion, in which case the Control-d character \fBEOT\fR and
the \fBESC\fR character have special significance when typed in at the end of a
terminal input line:
.sp
.ne 2
.na
\fB\fBEOT\fR\fR
.ad
.RS 7n
Print a list of all filenames that start with the preceding string.
.RE

.sp
.ne 2
.na
\fB\fBESC\fR\fR
.ad
.RS 7n
Replace the preceding string with the longest unambiguous extension.
.RE

.RE

.sp
.ne 2
.na
\fB\fBhardpaths\fR\fR
.ad
.RS 13n
If set, pathnames in the directory stack are resolved to contain no
symbolic-link components.
.RE

.sp
.ne 2
.na
\fB\fBhistchars\fR\fR
.ad
.RS 13n
A two-character string. The first character replaces \fB!\fR as the
history-substitution character. The second replaces the carat (\fB^\fR) for
quick substitutions.
.RE

.sp
.ne 2
.na
\fB\fBhistory\fR\fR
.ad
.RS 13n
The number of lines saved in the history list. A very large number can use up
all of the C shell's memory. If not set, the C shell saves only the most recent
command.
.RE

.sp
.ne 2
.na
\fB\fBhome\fR\fR
.ad
.RS 13n
The user's home directory. The filename expansion of ~ refers to the value of
this variable.
.RE

.sp
.ne 2
.na
\fB\fBignoreeof\fR\fR
.ad
.RS 13n
If set, the shell ignores \fBEOF\fR from terminals. This protects against
accidentally killing a C shell by typing a Control-d.
.RE

.sp
.ne 2
.na
\fB\fBmail\fR\fR
.ad
.RS 13n
A list of files where the C shell checks for mail. If the first word of the
value is a number, it specifies a mail checking interval in seconds (default 5
minutes).
.RE

.sp
.ne 2
.na
\fB\fBnobeep\fR\fR
.ad
.RS 13n
Suppress the bell during command completion when asking the C shell to extend
an ambiguous filename.
.RE

.sp
.ne 2
.na
\fB\fBnoclobber\fR\fR
.ad
.RS 13n
Restrict output redirection so that existing files are not destroyed by
accident. \fB>\fR redirections can only be made to new files. \fB>>\fR
redirections can only be made to existing files.
.RE

.sp
.ne 2
.na
\fB\fBnoglob\fR\fR
.ad
.RS 13n
Inhibit filename substitution. This is most useful in shell scripts once
filenames (if any) are obtained and no further expansion is desired.
.RE

.sp
.ne 2
.na
\fB\fBnonomatch\fR\fR
.ad
.RS 13n
Return the filename substitution pattern, rather than an error, if the pattern
is not matched. Malformed patterns still result in errors.
.RE

.sp
.ne 2
.na
\fB\fBnotify\fR\fR
.ad
.RS 13n
If set, the shell notifies you immediately as jobs are completed, rather than
waiting until just before issuing a prompt.
.RE

.sp
.ne 2
.na
\fB\fBpath\fR\fR
.ad
.RS 13n
The list of directories in which to search for commands. \fBpath\fR is
initialized from the environment variable \fBPATH\fR, which the C shell updates
whenever \fBpath\fR changes. A null word ('') specifies the current directory.
The default is typically \fB(/usr/bin .)\fR. One can override this initial
search path upon \fBcsh\fR start-up by setting it in \fB\&.cshrc\fR or
\fB\&.login\fR (for login shells only). If \fBpath\fR becomes unset, only full
pathnames execute. An interactive C shell normally hashes the contents of the
directories listed after reading \fB\&.cshrc\fR, and whenever \fBpath\fR is
reset. If new commands are added, use the \fBrehash\fR command to update the
table.
.RE

.sp
.ne 2
.na
\fB\fBprompt\fR\fR
.ad
.RS 13n
The string an interactive C shell prompts with. Noninteractive shells leave the
\fBprompt\fR variable unset. Aliases and other commands in the \fB\&.cshrc\fR
file that are only useful interactively, can be placed after the following
test: `\fBif ($?prompt == 0) exit\fR', to reduce startup time for
noninteractive shells. A \fB!\fR in the \fBprompt\fR string is replaced by the
current event number. The default prompt is \fIhostname\fR\fB%\fR for mere
mortals, or \fIhostname\fR\fB#\fR for the privileged user.
.sp
The setting of \fB$prompt\fR has three meanings:
.sp
.ne 2
.na
\fB\fB$prompt\fR not set\fR
.ad
.RS 25n
non-interactive shell, test \fB$?prompt\fR.
.RE

.sp
.ne 2
.na
\fB\fB$prompt\fR set but \fB== ""\fR\fR
.ad
.RS 25n
\fB\&.cshrc\fR called by the \fBwhich\fR(1) command.
.RE

.sp
.ne 2
.na
\fB\fB$prompt\fR set and \fB!= ""\fR\fR
.ad
.RS 25n
normal interactive shell.
.RE

.RE

.sp
.ne 2
.na
\fB\fBsavehist\fR\fR
.ad
.RS 13n
The number of lines from the history list that are saved in ~/.history when the
user logs out. Large values for \fBsavehist\fR slow down the C shell during
startup.
.RE

.sp
.ne 2
.na
\fB\fBshell\fR\fR
.ad
.RS 13n
The file in which the C shell resides. This is used in forking shells to
interpret files that have execute bits set, but that are not executable by the
system.
.RE

.sp
.ne 2
.na
\fB\fBstatus\fR\fR
.ad
.RS 13n
The status returned by the most recent command. If that command terminated
abnormally, 0200 is added to the status. Built-in commands that fail return
exit status 1; all other built-in commands set status to 0.
.RE

.sp
.ne 2
.na
\fB\fBtime\fR\fR
.ad
.RS 13n
Control automatic timing of commands. Can be supplied with one or two values.
The first is the reporting threshold in \fBCPU\fR seconds. The second is a
string of tags and text indicating which resources to report on. A tag is a
percent sign (\fB%\fR) followed by a single upper-case letter (unrecognized
tags print as text):
.sp
.ne 2
.na
\fB\fB%D\fR\fR
.ad
.RS 6n
Average amount of unshared data space used in Kilobytes.
.RE

.sp
.ne 2
.na
\fB\fB%E\fR\fR
.ad
.RS 6n
Elapsed (wallclock) time for the command.
.RE

.sp
.ne 2
.na
\fB\fB%F\fR\fR
.ad
.RS 6n
Page faults.
.RE

.sp
.ne 2
.na
\fB\fB%I\fR\fR
.ad
.RS 6n
Number of block input operations.
.RE

.sp
.ne 2
.na
\fB\fB%K\fR\fR
.ad
.RS 6n
Average amount of unshared stack space used in Kilobytes.
.RE

.sp
.ne 2
.na
\fB\fB%M\fR\fR
.ad
.RS 6n
Maximum real memory used during execution of the process.
.RE

.sp
.ne 2
.na
\fB\fB%O\fR\fR
.ad
.RS 6n
Number of block output operations.
.RE

.sp
.ne 2
.na
\fB\fB%P\fR\fR
.ad
.RS 6n
Total CPU time \(em U (user) plus S (system) \(em as a percentage of E
(elapsed) time.
.RE

.sp
.ne 2
.na
\fB\fB%S\fR\fR
.ad
.RS 6n
Number of seconds of CPU time consumed by the kernel on behalf of the user's
process.
.RE

.sp
.ne 2
.na
\fB\fB%U\fR\fR
.ad
.RS 6n
Number of seconds of \fBCPU\fR time devoted to the user's process.
.RE

.sp
.ne 2
.na
\fB\fB%W\fR\fR
.ad
.RS 6n
Number of swaps.
.RE

.sp
.ne 2
.na
\fB\fB%X\fR\fR
.ad
.RS 6n
Average amount of shared memory used in Kilobytes.
.RE

The default summary display outputs from the \fB%U\fR, \fB%S\fR, \fB%E\fR,
\fB%P\fR, \fB%X\fR, \fB%D\fR, \fB%I\fR, \fB%O\fR, \fB%F\fR, and \fB%W\fR tags,
in that order.
.RE

.sp
.ne 2
.na
\fB\fBverbose\fR\fR
.ad
.RS 13n
Display each command after history substitution takes place.
.RE

.SS "Large File Behavior"
.LP
See \fBlargefile\fR(5) for the description of the behavior of \fBcsh\fR when
encountering files greater than or equal to 2 Gbyte (2^31 bytes).
.SH FILES
.ne 2
.na
\fB\fB~/.cshrc\fR\fR
.ad
.RS 15n
Read at beginning of execution by each shell.
.RE

.sp
.ne 2
.na
\fB\fB~/.login\fR\fR
.ad
.RS 15n
Read by login shells after \fB\&.cshrc\fR at login.
.RE

.sp
.ne 2
.na
\fB\fB~/.logout\fR\fR
.ad
.RS 15n
Read by login shells at logout.
.RE

.sp
.ne 2
.na
\fB\fB~/.history\fR\fR
.ad
.RS 15n
Saved history for use at next login.
.RE

.sp
.ne 2
.na
\fB\fB/usr/bin/sh\fR\fR
.ad
.RS 15n
The Bourne shell, for shell scripts not starting with a `\fB#\fR'.
.RE

.sp
.ne 2
.na
\fB\fB/tmp/sh*\fR\fR
.ad
.RS 15n
Temporary file for `\fB<<\fR\&'.
.RE

.sp
.ne 2
.na
\fB\fB/etc/passwd\fR\fR
.ad
.RS 15n
Source of home directories for `~\fIname\fR'.
.RE

.SH ATTRIBUTES
.LP
See \fBattributes\fR(5) for descriptions of the following attributes:
.sp

.sp
.TS
box;
c | c
l | l .
ATTRIBUTE TYPE	ATTRIBUTE VALUE
_
CSI	Enabled
.TE

.SH SEE ALSO
.LP
\fBbc\fR(1), \fBecho\fR(1), \fBlimit\fR(1), \fBlogin\fR(1), \fBls\fR(1),
\fBmore\fR(1), \fBpfcsh\fR(1), \fBpfexec\fR(1), \fBps\fR(1), \fBsh\fR(1),
\fBshell_builtins\fR(1), \fBtset\fR(1B), \fBwhich\fR(1), \fBdf\fR(1M),
\fBswap\fR(1M), \fBsysdef\fR(1M), \fBaccess\fR(2), \fBexec\fR(2),
\fBfork\fR(2), \fBpipe\fR(2), \fBa.out\fR(4), \fBascii\fR(5),
\fBattributes\fR(5), \fBenviron\fR(5), \fBlargefile\fR(5), \fBtermio\fR(7I)
.SH DIAGNOSTICS
.ne 2
.na
\fB\fBYou have stopped jobs.\fR\fR
.ad
.RS 26n
You attempted to exit the C shell with stopped jobs under job control. An
immediate second attempt to exit succeeds, terminating the stopped jobs.
.RE

.SH WARNINGS
.LP
The use of \fBsetuid\fR shell scripts is \fIstrongly\fR discouraged.
.SH NOTES
.LP
Words can be no longer than 1024 bytes. The system limits argument lists to
1,048,576 bytes. However, the maximum number of arguments to a command for
which filename expansion applies is 1706. Command substitutions can expand to
no more characters than are allowed in the argument list. To detect looping,
the shell restricts the number of \fBalias\fR substitutions on a single line to
20.
.sp
.LP
When a command is restarted from a stop, the shell prints the directory it
started in if this is different from the current directory; this can be
misleading (that is, wrong) as the job might have changed directories
internally.
.sp
.LP
Shell built-in functions are not stoppable/restartable. Command sequences of
the form \fIa\fR \fIb\fR \fIc\fR are also not handled gracefully when stopping
is attempted. If you suspend \fIb\fR, the shell never executes \fIc\fR. This is
especially noticeable if the expansion results from an alias. It can be avoided
by placing the sequence in parentheses to force it into a subshell.
.sp
.LP
Commands within loops, prompted for by \fB?\fR, are not placed in the
\fIhistory\fR list.
.sp
.LP
Control structures should be parsed rather than being recognized as built-in
commands. This would allow control commands to be placed anywhere, to be
combined with \fB|\fR, and to be used with \fB&\fR and \fB;\fR metasyntax.
.sp
.LP
It should be possible to use the \fB:\fR modifiers on the output of command
substitutions. There are two problems with \fB:\fR modifier usage on variable
substitutions: not all of the modifiers are available, and only one modifier
per substitution is allowed.
.sp
.LP
The \fBg\fR (global) flag in history substitutions applies only to the first
match in each word, rather than all matches in all words. The common text
editors consistently do the latter when given the \fBg\fR flag in a
substitution command.
.sp
.LP
Quoting conventions are confusing. Overriding the escape character to force
variable substitutions within double quotes is counterintuitive and
inconsistent with the Bourne shell.
.sp
.LP
Symbolic links can fool the shell. Setting the \fBhardpaths\fR variable
alleviates this.
.sp
.LP
It is up to the user to manually remove all duplicate pathnames accrued from
using built-in commands as
.sp
.in +2
.nf
set path = \fIpathnames\fR
.fi
.in -2
.sp

.sp
.LP
or
.sp
.in +2
.nf
setenv PATH = \fIpathnames\fR
.fi
.in -2
.sp

.sp
.LP
more than once. These often occur because a shell script or a \fB\&.cshrc\fR
file does something like
.sp
.in +2
.nf
`set path=(/usr/local /usr/hosts $path)'
.fi
.in -2
.sp

.sp
.LP
to ensure that the named directories are in the pathname list.
.sp
.LP
The only way to direct the standard output and standard error separately is by
invoking a subshell, as follows:
.sp
.in +2
.nf
\fIcommand\fR > \fIoutfile\fR ) >& \fIerrorfile\fR
.fi
.in -2
.sp

.sp
.LP
Although robust enough for general use, adventures into the esoteric periphery
of the C shell can reveal unexpected quirks.
.sp
.LP
If you start \fBcsh\fR as a login shell and you do not have a \fB\&.login\fR in
your home directory, then the \fBcsh\fR reads in the \fB/etc/.login\fR.
.sp
.LP
When the shell executes a shell script that attempts to execute a non-existent
command interpreter, the shell returns an erroneous diagnostic message that the
shell script file does not exist.
.SH BUGS
.LP
As of this writing, the \fBtime\fR built-in command does \fBnot\fR compute the
last 6 fields of output, rendering the output to erroneously report the value
\fB0\fR for these fields:
.sp
.in +2
.nf
example %\fBtime ls -R\fR
        9.0u 11.0s 3:32 10% 0+0k 0+0io 0pf+0w
.fi
.in -2
.sp

