'\" te
.\"  Copyright (c) 2000, Sun Microsystems, Inc.
.\"  All Rights Reserved
.\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
.\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
.TH VSPRINTF 9F "May 6, 1996"
.SH NAME
vsprintf \- format characters in memory
.SH SYNOPSIS
.LP
.nf
#include <sys/varargs.h>
 #include <sys/ddi.h>
 #include <sys/sunddi.h>



\fBchar *\fR\fBvsprintf\fR(\fBchar *\fR\fIbuf\fR, \fBconst char *\fR\fIfmt\fR, \fBva_list\fR \fIap\fR);
.fi

.SH INTERFACE LEVEL
.sp
.LP
Solaris DDI specific (Solaris DDI).
.SH PARAMETERS
.sp
.ne 2
.na
\fB\fIbuf\fR \fR
.ad
.RS 8n
Pointer to a character string.
.RE

.sp
.ne 2
.na
\fB\fIfmt\fR \fR
.ad
.RS 8n
Pointer to a character string.
.RE

.sp
.ne 2
.na
\fB\fIap\fR \fR
.ad
.RS 8n
Pointer to a variable argument list.
.RE

.SH DESCRIPTION
.sp
.LP
\fBvsprintf()\fR builds a string in \fIbuf\fR under the control of the format
\fIfmt\fR. The format is a character string with either plain characters, which
are simply copied into \fIbuf\fR, or conversion specifications, each of which
converts zero or more arguments, again copied into \fIbuf\fR. The results are
unpredictable if there are insufficient arguments for the format;  excess
arguments are simply ignored. It is the user's responsibility to ensure that
enough storage is available for \fIbuf\fR.
.sp
.LP
\fIap\fR contains the list of arguments used by the conversion specifications
in \fIfmt\fR. \fIap\fR is a variable argument list and must be initialized by
calling  \fBva_start\fR(9F). \fBva_end\fR(9F) is used to clean up and must be
called after each traversal of the list. Multiple traversals of the argument
list, each bracketed by  \fBva_start\fR(9F) and  \fBva_end\fR(9F), are
possible.
.sp
.LP
Each conversion specification is introduced by the \fB%\fR character, after
which the following appear in sequence:
.sp
.LP
An optional decimal digit specifying a minimum field width for numeric
conversion. The converted value will be right-justified and padded with leading
zeroes if it has fewer characters than the minimum.
.sp
.LP
An optional \fBl\fR (\fBll\fR) specifying that a following \fBd\fR, \fBD\fR,
\fBo\fR, \fBO\fR, \fBx\fR, \fBX\fR, or \fBu\fR conversion character applies to
a \fBlong\fR (\fBlong long\fR) integer argument. An \fBl\fR (\fBll\fR) before
any other conversion character is ignored.
.sp
.LP
A character indicating the type of conversion to be applied:
.sp
.ne 2
.na
\fB\fBd\fR,\fBD\fR,\fBo\fR,\fBO\fR,\fBx\fR,\fBX\fR,\fBu\fR\fR
.ad
.RS 17n
The integer argument is converted to signed decimal (\fBd\fR, \fBD\fR),
unsigned octal (\fBo\fR, \fBO\fR), unsigned hexadecimal (\fBx\fR, \fBX\fR) or
unsigned decimal (\fBu\fR), respectively, and copied. The letters \fBabcdef\fR
are used for \fBx\fR conversion. The letters \fBABCDEF\fR are used for \fBX\fR
conversion.
.RE

.sp
.ne 2
.na
\fB\fBc\fR\fR
.ad
.RS 17n
The character value of the argument is copied.
.RE

.sp
.ne 2
.na
\fB\fBb\fR\fR
.ad
.RS 17n
This conversion uses two additional arguments. The first is an integer, and is
converted according to the base specified in the second argument. The second
argument is a character string in the form
\fB<\fR\fIbase\fR\fB>[<\fR\fIarg\fR\fB>\|.\|.\|.\|].\fR The base supplies the
conversion base for the first argument as a binary value;  \e10 gives octal,
\e20 gives hexadecimal. Each subsequent <arg> is a sequence of characters, the
first of which is the bit number to be tested, and subsequent characters, up to
the next bit number or terminating null, supply the name of the bit.
.RE

.sp
.ne 2
.na
\fB\fR
.ad
.RS 17n
A bit number is a binary-valued character in the range \fB1-32\fR. For each bit
set in the first argument, and named in the second argument, the bit names are
copied, separated by commas, and bracketed by \fB<\fR and \fB>\fR. Thus, the
following function call would generate \fBreg=3<BitTwo,BitOne>\en\fR in
\fIbuf\fR.
.RE

.sp
.ne 2
.na
\fB\fR
.ad
.RS 17n
\fBvsprintf(buf, "reg=%b\en", 3, "\e10\e2BitTwo\e1BitOne")\fR
.RE

.sp
.ne 2
.na
\fB\fBs\fR\fR
.ad
.RS 17n
The argument is taken to be a string (character pointer), and characters from
the string are copied until a null character is encountered.  If the character
pointer is \fINULL\fR on \fBSPARC\fR, the string \fB<nullstring>\fR is used in
its place; on x86, it is undefined.
.RE

.sp
.ne 2
.na
\fB\fB%\fR\fR
.ad
.RS 17n
Copy a \fB%\fR; no argument is converted.
.RE

.SH RETURN VALUES
.sp
.LP
\fBvsprintf()\fR returns its first parameter, \fIbuf\fR.
.SH CONTEXT
.sp
.LP
\fBvsprintf()\fR can be called from user, kernel, or interrupt context.
.SH EXAMPLES
.LP
\fBExample 1 \fRUsing \fBvsprintf()\fR
.sp
.LP
In this example, \fBxxerror()\fR accepts a pointer to a  \fBdev_info_t\fR
structure \fBdip\fR, an error level \fBlevel\fR, a format  \fBfmt\fR, and a
variable number of arguments.  The routine uses \fBvsprintf()\fR to format the
error message in  \fBbuf\fR. Note that  \fBva_start\fR(9F) and \fBva_end\fR(9F)
bracket the call to \fBvsprintf()\fR. \fBinstance\fR, \fBlevel\fR, \fBname\fR,
and  \fBbuf\fR are then passed to \fBcmn_err\fR(9F).

.sp
.in +2
.nf
#include <sys/varargs.h>
#include <sys/ddi.h>
#include <sys/sunddi.h>
#define MAX_MSG 256

void
xxerror(dev_info_t *dip, int level, const char *fmt, .\|.\|.\|)
{
	va_list		ap;
	int		instance;
	char		buf[MAX_MSG],
			*name;

	instance = ddi_get_instance(dip);
	name = ddi_binding_name(dip);

	/* format buf using fmt and arguments contained in ap */
	va_start(ap, fmt);
	vsprintf(buf, fmt, ap); 	
	va_end(ap);

	/* pass formatted string to cmn_err(9F) */
	cmn_err(level, "%s%d: %s", name, instance, buf);
}
.fi
.in -2

.SH SEE ALSO
.sp
.LP
\fBcmn_err\fR(9F), \fBddi_binding_name\fR(9F), \fBddi_get_instance\fR(9F),
\fBva_arg\fR(9F)
.sp
.LP
\fIWriting Device Drivers\fR
