#!/bin/sh
#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#
#
# Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#
#
# r.manifest - smf(5) manifest remove class action script
#

MFSTSCAN=/lib/svc/bin/mfstscan
SVCCFG=/usr/sbin/svccfg
SVCPROP=/usr/bin/svcprop
SVCADM=/usr/sbin/svcadm
AWK=/usr/bin/awk
CP=/usr/bin/cp
RM=/usr/bin/rm

# number of seconds to wait before killing processes 
STOP_DELAY=60

#   
# Helper function. Delete the manifest hash value.
# Arguments: $1: manifest file.
#
svc_delhash()
{
	$SVCCFG delhash $1 >/dev/null 2>&1
	if [ "$?" != "0" ];then
		# this Solaris release doesn't have delhash command
		pg_name=`$MFSTSCAN -t $1`
		if $SVCPROP -q -p $pg_name smf/manifest; then
			$SVCCFG -s smf/manifest delpg $pg_name
		fi
	fi
}

#
# Helper function. Handle services deathrow file.
# Arguments: $1:manifest file, $2:package name.
#
svc_deathrow()
{
	DEATHROW_FILE=${PKG_INSTALL_ROOT}/etc/svc/deathrow
	# remove alternate root from manifest path
	manifest=`echo "${PKG_INSTALL_ROOT} $1" | $AWK \
	    '{ print substr($2, length($1)+1); }'`
	#
	# Services deathrow file handling, file format:
	# <fmri>< ><manifest file>< ><package name>
	# (field separator is a space character)
	#
	# Manifest file could be from another Solaris version, bypass the
	# the service bundle and validation (we only need the fmris list).
	# Calling svccfg inventory with SVCCFG_NOVALIDATE=1 is safe because
	# there is no access to the alternate repository.
	#
	ENTITIES=`SVCCFG_NOVALIDATE=1 $SVCCFG inventory $1`
	for fmri in $ENTITIES; do
		# add to services deathrow file
		echo ${fmri} ${manifest} $2 >> ${DEATHROW_FILE}
	done
}

wait_disable() {
	svcinst=$1
	wait_time=$2

	while [ ${nsec:=0} -lt $wait_time ]; do
		state=`$SVCPROP -p restarter/state $svcinst`
		if [ "$state" = "disabled" -o "$state" = "maintenance" ]; then
			nstate=`$SVCPROP -p restarter/next_state $svcinst`
			if [ "$nstate" = "none" ]; then
				return 0
			fi
		fi
		/usr/bin/sleep 1
		nsec=`expr ${nsec} + 1`
	done

	return 1
}

if [ "$PKG_INSTALL_ROOT" != "" -a "$PKG_INSTALL_ROOT" != "/" ]; then
	#
	# We can't safely disable the service in this case.
	#
	smf_alive=no
else
	#
	# We can verify if the service is disabled prior to
	# removal.
	#
	if [ -r /etc/svc/volatile/repository_door ]; then
		smf_alive=yes
	fi
fi

while read mfst; do
	if [ "$smf_alive" = "yes" ]; then
		ENTITIES=`$SVCCFG inventory $mfst`

		for fmri in $ENTITIES; do

			# Determine whether fmri refers to an instance or a service.
			$SVCPROP -p restarter/state $fmri >/dev/null 2>&1
			if [ $? -eq 1 ]; then
				# this is a service fmri, all instances have been deleted
				$SVCCFG delete $fmri 2>/dev/null
				# process next instance
				continue
			fi

			#
			# Try to disable the instance within a reasonable amount of time
			# (eg. 60 secs). If it fails, forcibly delete the instance.
			#
			echo "Waiting up to $STOP_DELAY seconds for $fmri to stop..."
			$SVCADM disable $fmri 2>/dev/null 
			if [ $? -eq 0 ]; then
				wait_disable $fmri $STOP_DELAY
				if [ $? -eq 0 ]; then
					# the instance is disabled and can be safely deleted
					$SVCCFG delete $fmri 2>/dev/null
					# process next instance
					continue
				fi
				echo "Failed to disable $fmri after $STOP_DELAY seconds"
			else
				echo "Failed to disable $fmri"
			fi

			echo "Force deleting $fmri"

			ctid=`$SVCPROP -p restarter/contract $fmri 2>/dev/null`
			tctid=`$SVCPROP -p restarter/transient_contract $fmri 2>/dev/null`

			$SVCCFG delete -f $fmri

			#
			# Kill any remaining processes.
			# pkill must occur after the delete to prevent startd
			# from retrying the STOP method.
			#
			if [ -n "${tctid}" -a "${tctid}" -gt 1 ]; then
				# kill the STOP method processes
				/usr/bin/pkill -9 -c $tctid
			fi
			if [ -n "${ctid}" -a "${ctid}" -gt 1 ]; then
				# kill any remaining running processes for the instance
				/usr/bin/pkill -9 -c $ctid
			fi
		done

		#
		# Delete the manifest hash value.
		#
		svc_delhash $mfst
	else
		# deathrow handling
		svc_deathrow $mfst $PKGINST
	fi

	$RM -f $mfst
done

exit 0
