/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/* LINTLIBRARY */
/* PROTOLIB1 */

/*
 * Copyright (c) 1998 by Sun Microsystems, Inc.
 * All rights reserved.
 */
#pragma ident	"%Z%%M%	%I%	%E% SMI"

#define	PORTMAP

#include <rpc/rpc.h>
#include <rpc/rac.h>
#include "rac_private.h"

/* clnt_dg.c */
CLIENT *clnt_dg_create(const int fd, struct netbuf *svcaddr,
    const rpcprog_t program, const rpcvers_t version, const uint_t sendsz,
    const uint_t recvsz);

/* clnt_generic.c */
CLIENT *clnt_create_vers(const char *hostname, const rpcprog_t prog,
    rpcvers_t *vers_out, const rpcvers_t vers_low, const rpcvers_t vers_high,
    const char *nettype);
CLIENT *clnt_create(const char *hostname, rpcprog_t prog, rpcvers_t vers,
    const char *nettype);
CLIENT *clnt_tp_create(const char *hostname, const rpcprog_t prog,
    const rpcvers_t vers, const struct netconfig *nconf);
CLIENT *clnt_tli_create(const int fd, const struct netconfig *nconf,
    struct netbuf *svcaddr, const rpcprog_t prog, const rpcvers_t vers,
    const uint_t sendsz, const uint_t recvsz);

/* clnt_vc.c */
CLIENT *clnt_vc_create(const int fd, struct netbuf *svcaddr,
    const rpcprog_t prog, const rpcvers_t vers, const uint_t sendsz,
    const uint_t recvsz);

/* rac.c */
void rac_drop(CLIENT *cl, void *h);
enum clnt_stat rac_poll(CLIENT *cl, void *h);
enum clnt_stat rac_recv(CLIENT *cl, void *h);
void *rac_send(CLIENT *cl, rpcproc_t proc, xdrproc_t xargs, void *argsp,
    xdrproc_t xresults, void *resultsp, struct timeval timeout);
int __rpc_dtbsize();
uint_t __rpc_get_t_size(t_scalar_t size, t_scalar_t bufsize);
uint_t __rpc_get_a_size(t_scalar_t size);
struct netconfig *__rpc_getconfip(char *nettype);
void *__rpc_setconf(char *nettype);
struct netconfig *__rpc_getconf(void *vhandle);
void __rpc_endconf(void *vhandle);
int __rpc_select_to_poll(int fdmax, fd_set *fdset, struct pollfd *p0);
int __rpc_timeval_to_msec(struct timeval *t);
void __seterr_reply(struct rpc_msg *msg, struct rpc_err *error);

/* rpcb_clnt.c */
bool_t __rpc_control(int request, void *info);
bool_t rpcb_set(const rpcprog_t program, const rpcvers_t version,
    const struct netconfig *nconf, const struct netbuf *address);
bool_t rpcb_unset(const rpcprog_t program, const rpcvers_t version,
    const struct netconfig *nconf);
int rpcb_getaddr(const rpcprog_t program, const rpcvers_t version,
    const struct netconfig *nconf, struct netbuf *address, const char *host);
rpcblist *rpcb_getmaps(const struct netconfig *nconf, const char *host);
enum clnt_stat rpcb_rmtcall(const struct netconfig *nconf, const char *host,
    const rpcprog_t prog, const rpcvers_t vers, const rpcproc_t proc,
    const xdrproc_t xdrargs, const caddr_t argsp, const xdrproc_t xdrres,
    const caddr_t resp, const struct timeval tout, struct netbuf *addr_ptr);
bool_t rpcb_gettime(const char *host, time_t *timep);
char *rpcb_taddr2uaddr(struct netconfig *nconf, struct netbuf *taddr);
struct netbuf *rpcb_uaddr2taddr(struct netconfig *nconf, char *uaddr);

/* xdr_rec.c */
void xdrrec_create(XDR *xdrs, const uint_t sendsize, const uint_t recvsize,
    const caddr_t tcp_handle,
    int (*readit)(void *, caddr_t, int), int (*writeit)(void *, caddr_t, int));
uint_t xdrrec_readbytes(XDR *xdrs, caddr_t addr, uint_t l);
bool_t xdrrec_skiprecord(XDR *xdrs);
bool_t xdrrec_eof(XDR *xdrs);
bool_t xdrrec_endofrecord(XDR *xdrs, bool_t sendnow);

/* xdr_rec_subr.c */

