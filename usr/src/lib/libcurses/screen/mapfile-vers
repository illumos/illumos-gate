#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#
#
# Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
#

#
# MAPFILE HEADER START
#
# WARNING:  STOP NOW.  DO NOT MODIFY THIS FILE.
# Object versioning must comply with the rules detailed in
#
#	usr/src/lib/README.mapfiles
#
# You should not be making modifications here until you've read the most current
# copy of that file. If you need help, contact a gatekeeper for guidance.
#
# MAPFILE HEADER END
#

$mapfile_version 2

SYMBOL_VERSION SUNW_1.1 {
    global:
	addch;
	addchnstr;
	addchstr;
	addnstr;
	addnwstr;
	addstr;
	addwch;
	addwchnstr;
	addwchstr;
	addwstr;
	attroff;
	attron;
	attrset;
	baudrate;
	beep;
	bkgd;
	bkgdset;
	border;
	box;
	can_change_color;
	cbreak;
	clear;
	clearok;
	clrtobot;
	clrtoeol;
	color_content;
	copywin;
	crmode;
	curs_set;
	def_prog_mode;
	def_shell_mode;
	delay_output;
	delch;
	del_curterm;
	deleteln;
	delscreen;
	delwin;
	derwin;
	doupdate;
	dupwin;
	echo;
	echochar;
	echowchar;
	endwin;
	erase;
	erasechar;
	filter;
	flash;
	flushinp;
	getch;
	getnwstr;
	getstr;
	_getsyx;
	getwch;
	getwin;
	getwstr;
	halfdelay;
	has_colors;
	has_ic;
	has_il;
	idcok;
	idlok;
	immedok;
	inch;
	inchnstr;
	inchstr;
	init_color;
	init_pair;
	initscr;
	innstr;
	innwstr;
	insch;
	insdelln;
	insertln;
	insnstr;
	insnwstr;
	insstr;
	instr;
	inswch;
	inswstr;
	intrflush;
	inwch;
	inwchnstr;
	inwchstr;
	inwstr;
	isendwin;
	is_linetouched;
	is_wintouched;
	keyname;
	keypad;
	killchar;
	leaveok;
	longname;
	meta;
	_meta;
	move;
	mvaddch;
	mvaddchnstr;
	mvaddchstr;
	mvaddnstr;
	mvaddnwstr;
	mvaddstr;
	mvaddwch;
	mvaddwchnstr;
	mvaddwchstr;
	mvaddwstr;
	mvcur;
	mvdelch;
	mvderwin;
	mvgetch;
	mvgetnwstr;
	mvgetstr;
	mvgetwch;
	mvgetwstr;
	mvinch;
	mvinchnstr;
	mvinchstr;
	mvinnstr;
	mvinnwstr;
	mvinsch;
	mvinsnstr;
	mvinsnwstr;
	mvinsstr;
	mvinstr;
	mvinswch;
	mvinswstr;
	mvinwch;
	mvinwchnstr;
	mvinwchstr;
	mvinwstr;
	mvprintw;
	mvscanw;
	mvwaddch;
	mvwaddchnstr;
	mvwaddchstr;
	mvwaddnstr;
	mvwaddnwstr;
	mvwaddstr;
	mvwaddwch;
	mvwaddwchnstr;
	mvwaddwchstr;
	mvwaddwstr;
	mvwdelch;
	mvwgetch;
	mvwgetnwstr;
	mvwgetstr;
	mvwgetwch;
	mvwgetwstr;
	mvwin;
	mvwinch;
	mvwinchnstr;
	mvwinchstr;
	mvwinnstr;
	mvwinnwstr;
	mvwinsch;
	mvwinsnstr;
	mvwinsnwstr;
	mvwinsstr;
	mvwinstr;
	mvwinswch;
	mvwinswstr;
	mvwinwch;
	mvwinwchnstr;
	mvwinwchstr;
	mvwinwstr;
	mvwprintw;
	mvwscanw;
	napms;
	newpad;
	newterm;
	newwin;
	nl;
	nocbreak;
	nocrmode;
	nodelay;
	noecho;
	nonl;
	noqiflush;
	noraw;
	notimeout;
	overlay;
	overwrite;
	pair_content;
	pechochar;
	pechowchar;
	pnoutrefresh;
	prefresh;
	printw;
	putp;
	putwin;
	qiflush;
	raw;
	redrawwin;
	refresh;
	reset_prog_mode;
	reset_shell_mode;
	resetty;
	restartterm;
	_ring;
	ripoffline;
	savetty;
	scanw;
	scr_dump;
	scr_init;
	scrl;
	scroll;
	scrollok;
	scr_restore;
	scr_set;
	_setecho;
	_setnonl;
	_setqiflush;
	setscrreg;
	setsyx;
	set_term;
	setterm;
	setupterm;
	slk_attroff;
	slk_attron;
	slk_attrset;
	slk_clear;
	slk_init;
	slk_label;
	slk_noutrefresh;
	slk_refresh;
	slk_restore;
	slk_set;
	slk_touch;
	standend;
	standout;
	start_color;
	subpad;
	subwin;
	syncok;
	termattrs;
	termname;
	tgetent;
	tgetflag;
	tgetnum;
	tgetstr;
	tgoto;
	tigetflag;
	tigetnum;
	tigetstr;
	timeout;
	touchline;
	touchwin;
	tparm;
	tputs;
	typeahead;
	unctrl;
	ungetch;
	ungetwch;
	untouchwin;
	vidattr;
	vidputs;
	vwprintw;
	vwscanw;
	waddch;
	waddchnstr;
	waddchstr;
	waddnstr;
	waddnwstr;
	waddstr;
	waddwch;
	waddwchnstr;
	waddwchstr;
	waddwstr;
	wadjcurspos;
	wattroff;
	wattron;
	wattrset;
	wbkgd;
	wbkgdset;
	wborder;
	wclear;
	wclrtobot;
	wclrtoeol;
	wcursyncup;
	wdelch;
	wdeleteln;
	wechochar;
	wechowchar;
	werase;
	wgetch;
	wgetnstr;
	wgetnwstr;
	wgetstr;
	wgetwch;
	wgetwstr;
	whline;
	winch;
	winchnstr;
	winchstr;
	winnstr;
	winnwstr;
	winsch;
	winsdelln;
	winsertln;
	winsnstr;
	winsnwstr;
	winsstr;
	winstr;
	winswch;
	winswstr;
	winwch;
	winwchnstr;
	winwchstr;
	winwstr;
	wmove;
	wmovenextch;
	wmoveprevch;
	wnoutrefresh;
	wprintw;
	wredrawln;
	wrefresh;
	wscanw;
	wscrl;
	wsetscrreg;
	wstandend;
	wstandout;
	wsyncdown;
	wsyncup;
	wtimeout;
	wtouchln;
	wvline;
};

SYMBOL_VERSION SUNWprivate_1.1 {
    global:
	acs32map		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	acs_map			{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	BC			{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	bit_attributes		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = 36;
					};
				};
	_blast_keys;
	boolcodes		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize[38];
					};
				};
	boolfnames		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize[38];
					};
				};
	boolnames		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize[38];
					};
				};
	box32;
	_branchto;
	_called_before		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = 1;
					};
				};
	_ccleanup;
	cconvert;
	cexpand;
	_change_color;
	_change_video;
	_chkinput;
	COLOR_PAIRS		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = 4;
					};
				};
	COLORS			{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = 4;
					};
				};
	COLS			{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = 4;
					};
				};
	_countchar;
	cpr;
	_csmax			{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = 2;
					};
				};
	cswidth			{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = 8;
					};
				};
	cur_bools		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	cur_nums		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	curscr			{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	curserr;
	curs_errno		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = 2;
					};
				};
	curs_err_strings	{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize[4];
					};
				};
	curses_version		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	_curs_mbstowcs;
	_curs_mbtowc;
	curs_parm_err		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = 32;
					};
				};
	_curs_scrwidth		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = 8;
					};
				};
	cur_strs		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	_curs_wcstombs;
	_curs_wctomb;
	cur_term		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	Def_term		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	_delay;
	delkey;
	delkeymap;
	delterm;
	_do_slk_noref		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	_do_slk_ref		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	_do_slk_tch		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	draino;
	_endwin			{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = 1;
					};
				};
$if _ELF64
	_first_term		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = 2032;
					};
				};
$elif _ELF32
	_first_term		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = 1340;
					};
				};
$else
$error unknown ELFCLASS
$endif
	fixterm;
	force_doupdate;
	_frst_bools		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = 38;
					};
				};
	_frst_nums		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = 68;
					};
				};
	_frst_strs		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize[395];
					};
				};
	_frst_tblstr		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = 1400;
					};
				};
	garbagedlines;
	garbagedwin;
	getattrs;
	getbegx;
	getbegy;
	getbkgd;
	getbmap;
	getcurx;
	getcury;
	getmaxx;
	getmaxy;
	getmouse;
	getparx;
	getpary;
	gettmode;
	hline;
	iexpand;
	_image;
	infotocap;
	init_acs;
	_init_costs;
	_init_HP_pair;
	initscr32;
	LINES			{ ASSERT = { TYPE = OBJECT; SIZE = 4; }; };
	m_addch;
	m_addstr;
	makenew;
	_makenew;
	map_button;
	_mbaddch;
	mbcharlen;
	_mbclrch;
	mbdisplen;
	mbeucw;
	mbgetwidth;
	_mbinsshift;
	mbscrw;
	_mbtrue			{ ASSERT = { TYPE = OBJECT; SIZE = 1; }; };
	_mbvalid;
	m_clear;
	memSset;
	m_erase;
	m_initscr;
	m_move;
	m_newterm;
	mouse_off;
	mouse_on;
	mouse_set;
	Mouse_status		{ ASSERT = { TYPE = OBJECT; SIZE = 20; }; };
	m_refresh;
	mvhline;
	mvvline;
	mvwhline;
	mvwvline;
	newkey;
	newscreen;
	newterm32;
	numcodes		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize[34];
					};
				};
	numfnames		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize[34];
					};
				};
	numnames		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize[34];
					};
				};
	Oldcolors		{ ASSERT = { TYPE = OBJECT; SIZE = 32; }; };
	ospeed			{ ASSERT = { TYPE = OBJECT; SIZE = 2; }; };
	_outch;
	_outchar;
	outchcount		{ ASSERT = { TYPE = OBJECT; SIZE = 4; }; };
	_outwch;
	_overlap;
	p32echochar;
	_padjust;
	PC			{ ASSERT = { TYPE = OBJECT; SIZE = 1; }; };
	pr_bfooting;
	pr_bheading;
	pr_boolean;
	pr_caprestrict;
	_prefresh;
	pr_heading;
	pr_init;
	pr_nfooting;
	pr_nheading;
	pr_number;
	prog_istermios		{ ASSERT = { TYPE = OBJECT; SIZE = 4; }; };
	progname		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				  FLAGS = NODIRECT;
				};
	pr_onecolumn;
	pr_sfooting;
	pr_sheading;
	pr_string;
	pr_width;
	_quick_echo;
	_quick_ptr		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	request_mouse_pos;
	resetterm;
	_rip_init		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	rmpadding;
	saveterm;
	_scr_all;
	scr_ll_dump;
	_scrmax			{ ASSERT = { TYPE = OBJECT; SIZE = 2; }; };
	scr_reset;
	setcurscreen;
	set_curterm;
	setcurterm;
	_setidln		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	setkeymap;
	shell_istermios		{ ASSERT = { TYPE = OBJECT; SIZE = 4; }; };
	_slk_init		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	slk_start;
	_slk_update;
	SP			{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	_sprintw;
	__sscans;
	stdscr			{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	_strbyte2code;
	_strcode2byte;
	strcodes		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize[395];
					};
				};
	strfnames		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize[395];
					};
				};
	strnames		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize[395];
					};
				};
	TABSIZE			{ ASSERT = { TYPE = OBJECT; SIZE = 4; }; };
	_tcsearch;
	termerr;
	term_errno		{ ASSERT = { TYPE = OBJECT; SIZE = 2; }; };
	term_err_strings	{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize[8];
					};
				};
	term_parm_err		{ ASSERT = { TYPE = OBJECT; SIZE = 32; }; };
	tgetch;
	tgetwch;
	tifgetflag;
	tifgetnum;
	tifgetstr;
	tinputfd;
	tparm_p0;
	tparm_p1;
	tparm_p2;
	tparm_p3;
	tparm_p4;
	tparm_p7;
	tpr;
	traceoff;
	traceon;
	_tstp;
	ttimeout;
	ttytype			{ ASSERT = { TYPE = OBJECT; SIZE = 1024; }; };
	_unctrl			{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize[128];
					};
				};
	UP			{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	_update_old_y_area;
	use_env;
	_use_env		{ ASSERT = { TYPE = OBJECT; SIZE = 1; }; };
	_useidln		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	vid32attr;
	vid32puts;
	vidupdate;
	_virtscr		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
	vline;
	w32addch;
	w32attroff;
	w32attron;
	w32attrset;
	w32echochar;
	w32insch;
	wcscrw;
	wmbinch;
	wmbmove;
	wmouse_position;
	_y16update		{
				  ASSERT = {
					  TYPE = OBJECT;
					  SIZE = addrsize;
					};
				};
    local:
	*;
};
