H
!rm -f termcap.c
0a
/*
 * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*
 * University Copyright- Copyright (c) 1982, 1986, 1988
 * The Regents of the University of California
 * All Rights Reserved
 *
 * University Acknowledgment- Portions of this document are derived from
 * software developed by the University of California, Berkeley, and its
 * contributors.
 */

/*
 * Simulation of termcap using terminfo.
 * This file is created from termcap.ed. DO NOT EDIT ME!
 */

/*
 * These are declared so people won't get undefineds if they use
 * old documentation.  We don't do anything with them.
 */

#include	<sys/types.h>
#include	<string.h>
#include	"curses_inc.h"

char	*UP;
char	*BC;
char	PC;
short	ospeed;

/* ARGSUSED */
int
tgetent(char *bp, char *name)
{
	int	rv;

	if (setupterm(name, 1, &rv) >= 0)
	/* Leave things as they were (for compatibility) */
		(void) reset_shell_mode();
	return (rv);
}

/* Make a 2 letter code into an integer we can switch on easily */
#define	_TWO(s1, s2)	(s1 + 256*s2)
#define	_TWOSTR(str)	_TWO(*str, str[1])

static	char	*
_stripdelays(char *inbuf, char *outbuf, int size)
{
	char	*saveoutbuf = outbuf;

	if (inbuf == NULL)
		return (0);

	while (size && *inbuf) {
		if (*inbuf == '$' && *(inbuf+1) == '<') {
			/* LINTED */
			while (*inbuf && *inbuf++ != '>');
		} else {
			size--;
			*outbuf++ = *inbuf++;
			*outbuf = 0;
		}
	}
	return (saveoutbuf);
}

/* generated by sort on caps */
static	short	booloffsets[] =
		{		/* generated by sort on caps */
.
!sed -e '1,/^--- begin bool/d' -e '/^--- end bool/,$d' -e '/^#/d' < caps | awk '{printf "\t/* \%s */\t\%d,\n", $3, i++}' | sort > ./tmp/termcap.tmp
.r !cat ./tmp/termcap.tmp
.a
		};

/* generated by sort on caps */
static	short	numoffsets[] =
		{
.
!sed -e '1,/^--- begin num/d' -e '/^--- end num/,$d' -e '/^#/d' < caps | awk '{printf "\t/* \%s */\t\%d,\n", $3, i++}' | sort > ./tmp/termcap.tmp
.r !cat ./tmp/termcap.tmp
.a
		};

/* generated by sort on caps */
static	short	stroffsets[] =
		{
.
!sed -e '1,/^--- begin str/d' -e '/^--- end str/,$d' -e '/^#/d' < caps | awk '{printf "\t/* \%s */\t\%d,\n", $3, i++}' | sort > ./tmp/termcap.tmp
.r !cat ./tmp/termcap.tmp
!rm ./tmp/termcap.tmp
.a
		};

/*
 * Return the value of the boolean capability tcstr.
 * Return 0 if the capability is not found.
 */

int
tgetflag(char *tcstr)
{
	char	*p;
	char	stripped[16];

	switch (_TWOSTR(tcstr)) {
	/* Special cases that do not have exact terminfo equivalents */
		case _TWO('b','s'):
			/* bs: true if ^H moves the cursor left */
			p = _stripdelays(cursor_left, stripped, 16);
			return (p && *p == 8 && p[1] == 0);
		case _TWO('p','t'):
			/* pt: true if terminal has ^I tabs every 8 spaces */
			p = _stripdelays(tab, stripped, 16);
			return (p && *p == 9 && p[1] == 0);
		case _TWO('n','c'):
			/* cr: true if ^M does not return the cursor */
			p = _stripdelays(carriage_return, stripped, 16);
			return (! (p && *p == 13 && p[1] == 0));
		case _TWO('n','s'):
			/* ns: true if no way to scroll the terminal */
			return (scroll_forward == NULL);
	}
	{
		int	n = _NUMELEMENTS(booloffsets);
		int	offset = _tcsearch(tcstr, booloffsets, boolcodes, n, 2);
		char	*bool_array = (char *) cur_bools;

		if (offset == -1)
			return (0);
		else
			return (bool_array[offset]);
	}
}

/*
 * Return the value of the numeric capability tcstr.
 * Return -1 if the capability is not found.
 */

int
tgetnum(char *tcstr)
{
	int	n = _NUMELEMENTS(numoffsets);
	int	offset = _tcsearch(tcstr, numoffsets, numcodes, n, 2);
	short	*num_array = (short *) cur_nums;

	if (offset == -1)
		return (-1);
	else
		return (num_array[offset]);
}

/*
 * Return the string capability for capability "id".  We also copy
 * it into *area for upward compatibility with a few programs that
 * actually expect it to be copied, at a slight cost in speed.
 */

char	*
tgetstr(char *tcstr, char **area)
{
	int	n = _NUMELEMENTS(stroffsets);
	int	offset = _tcsearch(tcstr, stroffsets, strcodes, n, 2);
	char	**str_array = (char **) cur_strs;
	char	*rv;

	if (offset == -1)
		return (0);
	rv = str_array[offset];
	if (area && *area && rv) {
		(void) strcpy(*area, rv);
		*area += strlen(rv) + 1;
	}
	return (rv);
}
.
w termcap.c
q
