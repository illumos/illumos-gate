/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*
 * Copyright 2018 Nexenta Systems, Inc.
 */


/* LINTLIBRARY */
/* PROTOLIB1 */

#include <sys/types.h>
#include <thread.h>
#include <synch.h>
#include <fcntl.h>
#include <sys/des.h>
#include <des/softdes.h>
#include <des/desdata.h>
#include <rpc/rpc.h>
#include <rpc/key_prot.h>
#include <rpc/des_crypt.h>
#include <rpc/pmap_prot.h>
#include <sys/ioctl.h>
#include <netdir.h>
#include <nss_netdir.h>
#include <nss_dbdefs.h>
#include <sac.h>
#include <netconfig.h>
#include <ndbm.h>
#include <rpcsvc/yp_prot.h>
#include <rpcsvc/ypclnt.h>
#include <rpcsvc/yppasswd.h>
#include <rpcsvc/ypupd.h>
#include <rpcsvc/nis.h>
#include <rpcsvc/nislib.h>
#include <sys/stream.h>
#include <sys/stropts.h>
#include <sys/tihdr.h>
#include <sys/timod.h>
#include <tiuser.h>


/*
 * Declare t_errno, even though this file is compiled '_REENTRANT'.  This
 * way t_errno is defined in the lint library, which is used for programs
 * compiled with _REENTRANT and those compiled without it.
 */
#ifdef t_errno
#undef t_errno
#endif
extern int t_errno;

/*
 * usr/src/lib/libnsl/common routines
 */

/* common.c */

/*
 * usr/src/lib/libnsl/des routines
 */

/* des_crypt.c */
int cbc_crypt(char *key, char *buf, size_t len, uint_t mode, char *ivec);
int ecb_crypt(char *key, char *buf, size_t len, uint_t mode);

/* des_soft.c */
void des_setparity(char *p);
int __des_crypt(char *buf, unsigned len, struct desparams *desp);

/* intl_crypt.c */

/* intl_soft.c */
int _des_crypt(char *buf, unsigned len, struct desparams *desp);

/*
 * usr/src/lib/libnsl/dial routines
 */

/* callers.c */

/* conn.c */

/* dial.c */
void undial(int fd);

/* getargs.c */

/* interface.c */

/* line.c */

/* stoa.c */

/* strecpy.c */

/* strsave.c */

/* sysfiles.c */

/* ulockf.c */

/* uucpdefs.c */

/*
 * usr/src/lib/libnsl/key routines
 */

/* gen_dhkeys.c */
void __gen_dhkeys(char *public, char *secret, char *pass);

/* publickey.c */
int getpublickey(const char *netname, char *pkey);
int __getpublickey_cached(char *netname, char *pkey, int *from_cache);
void __getpublickey_flush(const char *netname);
int getsecretkey(const char *netname, char *skey, const char *passwd);

/* xcrypt.c */
int xencrypt(char *secret, char *passwd);
int xdecrypt(char *secret, char *passwd);
int passwd2des(char *pw, char *key);

/*
 * usr/src/lib/libnsl/netdir routines
 */

/* netdir.c */
int *__nderror(void);
int netdir_getbyname(struct netconfig *tp, struct nd_hostserv *serv,
				struct nd_addrlist **addrs);
int netdir_getbyaddr(struct netconfig *tp, struct nd_hostservlist **serv,
				struct netbuf *addr);
int __netdir_getbyaddr_nosrv(struct netconfig *tp,
				struct nd_hostservlist **serv,
				struct netbuf *addr);
int netdir_options(struct netconfig *tp, int option, int fd, char *par);
struct netbuf *uaddr2taddr(struct netconfig *tp, char *addr);
char *taddr2uaddr(struct netconfig *tp, struct netbuf *addr);
void netdir_free(void *ptr, int type);
char *netdir_sperror(void);
void netdir_perror(char *s);

/*
 * usr/src/lib/libnsl/netselect routines
 */

/* netselect.c */
void *setnetconfig(void);
int endnetconfig(void *vdata);
struct netconfig *getnetconfig(void *vdata);
struct netconfig *getnetconfigent(const char *netid);
void freenetconfigent(struct netconfig *netp);
void *setnetpath(void);
int endnetpath(void *vdata);
struct netconfig *getnetpath(void *vdata);
char *nc_sperror(void);
void nc_perror(const char *string);

/*
 * usr/src/lib/libnsl/nis/gen routines
 */

/* nis_subr.c */
name_pos nis_dir_cmp(nis_name n1, nis_name n2);
nis_name nis_local_group(void);
nis_name nis_domain_of(char *s);
nis_name nis_leaf_of_r(const nis_name  s, char *buf, size_t bufsize);
nis_name nis_leaf_of(char *s);
nis_name nis_name_of(char *s);
nis_name nis_local_directory(void);
nis_name nis_local_host(void);
void nis_destroy_object(nis_object *obj);
nis_object *nis_clone_object(nis_object *obj, nis_object *dest);
nis_object *nis_read_obj(char *f);
int nis_write_obj(char *f, nis_object *o);
void *nis_get_static_storage(struct nis_sdata *bs, u_int el, u_int nel);
/*
 * char *nis_old_data(char *s);
 * char *nis_data(char *s);
 */

/* nis_xdr.c */
bool_t xdr_nis_attr(XDR *xdrs, nis_attr *objp);
bool_t xdr_nis_name(XDR *xdrs, nis_name *objp);
bool_t xdr_endpoint(XDR *xdrs, endpoint *objp);
bool_t xdr_nis_server(XDR *xdrs, nis_server *objp);
bool_t xdr_directory_obj(XDR *xdrs, directory_obj *objp);
bool_t xdr_entry_obj(XDR *xdrs, entry_obj *objp);
bool_t xdr_table_obj(XDR *xdrs, table_obj *objp);
bool_t xdr_objdata(XDR *xdrs, objdata *objp);
bool_t xdr_nis_oid(XDR *xdrs, nis_oid *objp);
bool_t xdr_nis_object(XDR *xdrs, nis_object *objp);
bool_t xdr_nis_object(XDR *xdrs, nis_object *objp);
bool_t xdr_log_entry_t(XDR *xdrs, log_entry_t *objp);
bool_t xdr_log_entry(XDR *xdrs, log_entry *objp);
bool_t xdr_nis_tag(XDR *xdrs, nis_tag *objp);
bool_t xdr_nis_bound_endpoint(XDR *xdrs, nis_bound_endpoint *objp);
bool_t xdr_nis_bound_directory(XDR *xdrs, nis_bound_directory *objp);
bool_t xdr_nis_active_endpoint(XDR *xdrs, nis_active_endpoint *objp);

/* thr_misc.c */

/*
 * usr/src/lib/libnsl/nsl routines
 */

/* _conn_util.c */

/* _data2.c */

/* _errlst.c */
int *__t_errno(void);

/* _utility.c */

/* t_accept.c */
int t_accept(int, int, struct t_call *);

/* t_alloc.c */
char *t_alloc(int, int, int);

/* t_bind.c */
int t_bind(int, struct t_bind *, struct t_bind *);

/* t_close.c */
int t_close(int);

/* t_connect.c */
int t_connect(int, struct t_call *, struct t_call *);

/* t_error.c */
void t_error(const char *);

/* t_free.c */
int t_free(char *, int);

/* t_getinfo.c */
int t_getinfo(int, struct t_info *);

/* t_getname.c */
int t_getname(int, struct netbuf *, int);

/* t_getstate.c */
int t_getstate(int);

/* t_listen.c */
int t_listen(int, struct t_call *);

/* t_look.c */
int t_look(int);

/* t_open.c */
int t_open(const char *, int, struct t_info *);

/* t_optmgmt.c */
int t_optmgmt(int, struct t_optmgmt *, struct t_optmgmt *);

/* t_rcv.c */
int t_rcv(int, char *, unsigned, int *);

/* t_rcvconnect.c */
int t_rcvconnect(int, struct t_call *);

/* t_rcvdis.c */
int t_rcvdis(int, struct t_discon *);

/* t_rcvrel.c */
int t_rcvrel(int);

/* t_rcvudata.c */
int t_rcvudata(int, struct t_unitdata *, int *);

/* t_rcvuderr.c */
int t_rcvuderr(int, struct t_uderr *);

/* t_snd.c */
int t_snd(int, char *, unsigned, int);

/* t_snddis */
int t_snddis(int, struct t_call *);

/* t_sndrel.c */
int t_sndrel(int);

/* t_sndudata.c */
int t_sndudata(int, struct t_unitdata *);

/* t_strerror.c */
char *t_strerror(int);

/* t_sync.c */
int t_sync(int);

/* t_unbind.c */
int t_unbind(int);

/*
 * struct t_iovec is defined in <xti.h>. But <xti.h> cannot be included
 * because inclusion of <xti.h> and <tiuser.h> are mututally exclusive
 * and <tiuser.h> is exposed by the inclusion of <rpc/rpc.h>. Needs to
 * be seen how to build llib-lnsl.ln from multiple source files to avoid
 * this problem.
 */
struct t_iovec {
	void	*iov_base;
	size_t	iov_len;
};

/* t_sndv.c */
int t_sndv(int, const struct t_iovec *,  unsigned int, int);

/* t_sndvudata.c */
int t_sndvudata(int, struct t_unitdata *, struct t_iovec *, unsigned int);

/* t_sndreldata.c */
int t_sndreldata(int, struct t_discon *);

/* t_rcvv.c */
int t_rcvv(int, struct t_iovec *, unsigned int, int *);

/* t_rcvvudata.c */
int t_rcvvudata(int, struct t_unitdata *, struct t_iovec *,
        unsigned int, int *);

/* t_rcvreldata.c */
extern int t_rcvreldata(int, struct t_discon *);

/* t_sysconf.c */
int t_sysconf(int);

/* xti_wrappers.c */
int _xti_accept(int, int, struct t_call *);
int _xti_xns5_accept(int, int, struct t_call *);
char *_xti_alloc(int, int, int);
int _xti_bind(int, struct t_bind *, struct t_bind *);
int _xti_close(int);
int _xti_connect(int, struct t_call *, struct t_call *);
int _xti_error(char *);
int _xti_free(char *, int);
int _xti_getinfo(int, struct t_info *);
int _xti_getprotaddr(int, struct t_bind *, struct t_bind *);
int _xti_getstate(int);
int _xti_listen(int, struct t_call *);
int _xti_look(int);
int _xti_open(char *, int, struct t_info *);
int _xti_optmgmt(int, struct t_optmgmt *, struct t_optmgmt *);
int _xti_rcv(int, char *, unsigned int, int *);
int _xti_rcvconnect(int, struct t_call *);
int _xti_rcvdis(int, struct t_discon *);
int _xti_rcvrel(int);
int _xti_rcvreldata(int, struct t_discon *);
int _xti_rcvudata(int, struct t_unitdata *, int *);
int _xti_rcvuderr(int, struct t_uderr *);
int _xti_rcvv(int, struct t_iovec *, unsigned int, int *);
int _xti_rcvvudata(int, struct t_unitdata *, struct t_iovec *,
    unsigned int, int *);
int _xti_snd(int, char *, unsigned int, int);
int _xti_xns5_snd(int, char *, unsigned int, int);
int _xti_snddis(int, struct t_call *);
int _xti_sndrel(int);
int _xti_sndreldata(int, struct t_discon *);
int _xti_sndudata(int, struct t_unitdata *);
int _xti_sndv(int, const struct t_iovec *, unsigned int, int);
int _xti_sndvudata(int, struct t_unitdata *, struct t_iovec *, unsigned int);
char *_xti_strerror(int);
int _xti_sync(int);
int _xti_sysconf(int);
int _xti_unbind(int);

/*
 * usr/src/lib/libnsl/nss routines
 */

/* gethostby_door.c */

/* gethostbyname_r.c */
struct hostent *_uncached_gethostbyname_r(const char *nam,
				struct hostent *result,
				char *buffer, int buflen, int *h_errnop);
struct hostent *_uncached_gethostbyaddr_r(const char *addr, int length,
				int type, struct hostent *result,
				char *buffer, int buflen, int *h_errnop);
struct hostent *gethostbyname_r(const char *nam, struct hostent *result,
				char *buffer, int buflen, int *h_errnop);
struct hostent *gethostbyaddr_r(const char *addr, int length, int type,
				struct hostent *result,
				char *buffer, int buflen, int *h_errnop);

/* gethostent.c */
struct hostent *gethostbyname(const char *nam);
struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type);
struct hostent *gethostent(void);

/* gethostent_r.c */
int sethostent(int stay);
int endhostent(void);
struct hostent *gethostent_r(struct hostent *result, char *buffer, int buflen,
				int *h_errnop);

/* getipnodeby.c */
void freehostent(struct hostent *hent);
struct hostent *getipnodebyaddr(const void *src, size_t len, int type,
				int *error_num);
struct hostent *getipnodebyname(const char *name, int af, int flags,
				int *error_num);

/* getrpcent.c */
struct rpcent *getrpcbyname(const char *nam);
struct rpcent *getrpcbynumber(const int num);
struct rpcent *getrpcent(void);

/* getrpcent_r.c */
struct rpcent *getrpcbyname_r(const char *name, struct rpcent *result,
				char *buffer, int buflen);
struct rpcent *getrpcbynumber_r(const int number, struct rpcent *result,
				char *buffer, int buflen);
void setrpcent(const int stay);
void endrpcent(void);
struct rpcent *getrpcent_r(struct rpcent *result, char *buffer, int buflen);

/* inet_matchaddr.c */
int inet_matchaddr(const void *, const char *);

/* netdir_inet.c */
int _get_hostserv_inetnetdir_byname(struct netconfig *nconf,
				struct nss_netdirbyname_in *args,
				union nss_netdirbyname_out *res);
int _get_hostserv_inetnetdir_byaddr(struct netconfig *nconf,
				struct nss_netdirbyaddr_in *args,
				union nss_netdirbyaddr_out *res);
int __nss2herrno(nss_status_t nsstat);
nss_status_t _herrno2nss(int h_errno);
struct hostent *_switch_gethostbyname_r(const char *name,
				struct hostent *result,
				char *buffer, int buflen, int *h_errnop);
struct hostent *_switch_gethostbyaddr_r(const char *addr, int len, int type,
				struct hostent *result,
				char *buffer, int buflen, int *h_errnop);
int str2servent(const char *instr, int lenstr, void *ent,
				char *buffer, int buflen);
void *__inet_get_local_interfaces(void);
void __inet_free_local_interfaces(void *p);
int __inet_address_is_local(void *p, struct in_addr addr);
int __inet_uaddr_is_local(void *p, struct netconfig *nc, char *uaddr);
int __inet_address_count(void *p);
ulong_t __inet_get_addr(void *p, int n);
char *__inet_get_uaddr(void *p, struct netconfig *nc, int n);
char *__inet_get_networka(void *p, int n);

/* netdir_inet_sundry.c */

/*
 * usr/src/lib/libnsl/rpc routines
 */

/* auth_des.c */
AUTH *authdes_seccreate(const char *servername, uint_t win,
			const char *timehost, const des_block *ckey);

/* auth_none.c */
AUTH *authnone_create(void);

/* auth_sys.c */
AUTH *authsys_create(const char *machname, uid_t uid, gid_t gid, int len,
			const gid_t *aup_gids);
AUTH *authsys_create_default(void);

/* auth_time.c */

/* authdes_prot.c */
bool_t xdr_authdes_cred(XDR *xdrs, struct authdes_cred *cred);
bool_t xdr_authdes_verf(XDR *xdrs, struct authdes_verf *verf);

/* authsys_prot.c */
bool_t xdr_authsys_parms(XDR *xdrs, struct authsys_parms *p);
bool_t xdr_uid_t(XDR *xdrs, uid_t *ip);
bool_t xdr_gid_t(XDR *xdrs, gid_t *ip);

/* clnt_bcast.c */
enum clnt_stat rpc_broadcast_exp(rpcprog_t prog, rpcvers_t vers, rpcproc_t proc,
		xdrproc_t xargs, caddr_t argsp, xdrproc_t xresults,
		caddr_t resultsp, resultproc_t eachresult, int inittime,
		int waittime, const char *netclass);
enum clnt_stat rpc_broadcast(rpcprog_t prog, rpcvers_t vers, rpcproc_t proc,
		xdrproc_t xargs, caddr_t argsp, xdrproc_t xresults,
		caddr_t resultsp, resultproc_t eachresult,
		const char *netclass);

/* clnt_dg.c */
CLIENT *clnt_dg_create(int fd, struct netbuf *svcaddr, rpcprog_t program,
		rpcvers_t version, uint_t sendsz, uint_t recvsz);

/* clnt_door.c */
CLIENT *clnt_door_create(rpcprog_t program, rpcvers_t version, uint_t sendsz);

/* clnt_generic.c */
CLIENT *clnt_create_vers(const char *hostname, rpcprog_t prog,
		rpcvers_t *vers_out, rpcvers_t vers_low,
		rpcvers_t vers_high, const char *nettype);
CLIENT *clnt_create_vers_timed(const char *hostname, rpcprog_t prog,
		rpcvers_t *vers_out, rpcvers_t vers_low,
		rpcvers_t vers_high, const char *nettype,
		const struct timeval *tp);
CLIENT *clnt_create(const char *hostname, rpcprog_t prog, rpcvers_t vers,
		const char *nettype);
CLIENT *clnt_create_timed(const char *hostname, rpcprog_t prog, rpcvers_t vers,
		const char *netclass, const struct timeval *tp);
CLIENT *clnt_tp_create(const char *hostname, rpcprog_t prog, rpcvers_t vers,
		const struct netconfig *nconf);
CLIENT *clnt_tp_create_timed(const char *hostname, rpcprog_t prog,
		rpcvers_t vers, const struct netconfig *nconf,
		const struct timeval *tp);
CLIENT *clnt_tli_create(int fd, const struct netconfig *nconf,
		struct netbuf *svcaddr, rpcprog_t prog, rpcvers_t vers,
		uint_t sendsz, uint_t recvsz);

/* clnt_perror.c */
char *clnt_sperror(const CLIENT *cl, const char *s);
void clnt_perror(const CLIENT *cl, const char *s);
void clnt_perrno(enum clnt_stat num);
char *clnt_spcreateerror(const char *s);
void clnt_pcreateerror(const char *s);
const char *clnt_sperrno(const enum clnt_stat stat);

/* clnt_raw.c */
CLIENT *clnt_raw_create(rpcprog_t prog, rpcvers_t vers);

/* clnt_simple.c */
enum clnt_stat rpc_call(const char *host, rpcprog_t prognum, rpcvers_t versnum,
		rpcproc_t procnum, xdrproc_t inproc, const char *in,
		xdrproc_t outproc, char *out, const char *netclass);

/* clnt_vc.c */
CLIENT *clnt_vc_create(int fd, struct netbuf *svcaddr, rpcprog_t prog,
		rpcvers_t vers, uint_t sendsz, uint_t recvsz);

/* getdname.c */
int getdomainname(char *name, int namelen);
int setdomainname(char *domain, int len);

/* gethostname.c */
int gethostname(char *hname, int hlen);

/* key_call.c */
int key_setsecret(const char *secretkey);
int key_secretkey_is_set(void);
int key_encryptsession_pk(const char *remotename, netobj *remotekey,
				des_block *deskey);
int key_decryptsession_pk(const char *remotename, netobj *remotekey,
				des_block *deskey);

int key_encryptsession(const char *remotename, des_block *deskey);
int key_decryptsession(const char *remotename, des_block *deskey);
int key_gendes(des_block *key);
int key_setnet(struct key_netstarg *arg);
int key_get_conv(char *pkey, des_block *deskey);
int key_call(ulong_t proc, xdrproc_t xdr_arg, char *arg, xdrproc_t xdr_rslt,
				char *rslt);

/* key_prot.c */
bool_t xdr_keystatus(XDR *xdrs, keystatus *objp);
bool_t xdr_keybuf(XDR *xdrs, keybuf objp);
bool_t xdr_netnamestr(XDR *xdrs, netnamestr *objp);
bool_t xdr_cryptkeyarg(XDR *xdrs, cryptkeyarg *objp);
bool_t xdr_cryptkeyarg2(XDR *xdrs, cryptkeyarg2 *objp);
bool_t xdr_cryptkeyres(XDR *xdrs, cryptkeyres *objp);
bool_t xdr_unixcred(XDR *xdrs, unixcred *objp);
bool_t xdr_getcredres(XDR *xdrs, getcredres *objp);
bool_t xdr_key_netstarg(XDR *xdrs, key_netstarg *objp);
bool_t xdr_key_netstres(XDR *xdrs, key_netstres *objp);

/* mt_misc.c */
#ifdef rpc_createerr
#undef rpc_createerr
#endif
struct rpc_createerr *__rpc_createerr(void);

/* netname.c */
int getnetname(char *name);
int __getnetnamebyuid(char *name, uid_t uid);
int user2netname(char *netname, const uid_t uid, const char *domain);
int host2netname(char *netname, const char *host, const char *domain);

/* netnamer.c */
int netname2user(const char *netname, uid_t *uidp, gid_t *gidp,
					int *gidlenp, gid_t *gidlist);
int netname2host(const char *netname, char *hostname, int hostlen);

/* openchild.c */

/* pmap_clnt.c */
int pmap_set(rpcprog_t program, rpcvers_t version, rpcprot_t protocol, ushort_t port);
bool_t pmap_unset(rpcprog_t program, rpcvers_t version);
ushort_t pmap_getport(struct sockaddr_in *address, rpcprog_t program,
			rpcvers_t version, rpcprot_t protocol);
struct pmaplist *pmap_getmaps(struct sockaddr_in *address);
enum clnt_stat pmap_rmtcall(struct sockaddr_in *addr, rpcprog_t prog,
			rpcvers_t vers, rpcproc_t proc, xdrproc_t xdrargs,
			caddr_t argsp, xdrproc_t xdrres, caddr_t resp,
			struct timeval tout, rpcport_t *port_ptr);

/* pmap_prot.c */
bool_t xdr_pmap(XDR *xdrs, struct pmap *objp);
bool_t xdr_pmaplist_ptr(XDR *xdrs, pmaplist_ptr *rp);
bool_t xdr_pmaplist(XDR *xdrs, PMAPLIST **rp);
bool_t xdr_rmtcallargs(XDR *xdrs, struct p_rmtcallargs *cap);
bool_t xdr_rmtcallres(XDR *xdrs, struct p_rmtcallres *crp);

/* rpc_callmsg.c */
bool_t xdr_callmsg(XDR *xdrs, struct rpc_msg *cmsg);

/* rpc_comdata.c */

/* rpc_generic.c */
int __rpc_dtbsize(void);
uint_t __rpc_get_t_size(t_scalar_t size, t_scalar_t bufsize);
uint_t __rpc_get_a_size(t_scalar_t size);
struct netconfig *__rpc_getconfip(char *nettype);
void *__rpc_setconf(char *nettype);
struct netconfig *__rpc_getconf(void *vhandle);
void __rpc_endconf(void *vhandle);
struct netconfig *__rpcfd_to_nconf(int fd, int servtype);
int __rpc_matchserv(int servtype, unsigned int nc_semantics);

/* rpc_prot.c */
bool_t xdr_opaque_auth(XDR *xdrs, struct opaque_auth *ap);
bool_t xdr_des_block(XDR *xdrs, des_block *blkp);
bool_t xdr_accepted_reply(XDR *xdrs, struct accepted_reply *ar);
bool_t xdr_rejected_reply(XDR *xdrs, struct rejected_reply *rr);
bool_t xdr_replymsg(XDR *xdrs, struct rpc_msg *rmsg);
bool_t xdr_callhdr(XDR *xdrs, struct rpc_msg *cmsg);
void __seterr_reply(struct rpc_msg *msg, struct rpc_err *error);

/* rpc_sel2poll.c */
int __rpc_select_to_poll(int fdmax, fd_set *fdset, struct pollfd *p0);
int __rpc_timeval_to_msec(struct timeval *t);

/* rpc_soc.c */
CLIENT *clntudp_bufcreate(struct sockaddr_in *raddr, rpcprog_t prog,
			rpcvers_t vers, struct timeval wait, int *sockp,
			uint_t sendsz, uint_t recvsz);
CLIENT *clntudp_create(struct sockaddr_in *raddr, rpcprog_t program,
			rpcvers_t version, struct timeval wait, int *sockp);
CLIENT *clnttcp_create(struct sockaddr_in *raddr, rpcprog_t prog,
			rpcvers_t vers, int *sockp, uint_t sendsz,
			uint_t recvsz);
CLIENT *clntraw_create(rpcprog_t prog, rpcvers_t vers);
SVCXPRT *svctcp_create(int fd, uint_t sendsize, uint_t recvsize);
SVCXPRT *svcudp_bufcreate(int fd, uint_t sendsize, uint_t recvsize);
SVCXPRT *svcfd_create(int fd, uint_t sendsize, uint_t recvsize);
SVCXPRT *svcudp_create(int fd);
SVCXPRT *svcraw_create(void);
int __rpc_bindresvport(int fd, struct sockaddr_in *sin, int *portp, int qlen);
void get_myaddress(struct sockaddr_in *addr);
ushort_t getrpcport(char *host, rpcprog_t prognum, rpcvers_t versnum, rpcprot_t proto);
int callrpc(char *host, rpcprog_t prognum, rpcvers_t versnum, rpcproc_t procnum,
		xdrproc_t inproc, char *in, xdrproc_t outproc, char *out);
int registerrpc(rpcprog_t prognum, rpcvers_t versnum, rpcproc_t procnum,
		char *(*progname)(), xdrproc_t inproc, xdrproc_t outproc);
enum clnt_stat clnt_broadcast(rpcprog_t prog, rpcvers_t vers, rpcproc_t proc,
		xdrproc_t xargs, caddr_t argsp, xdrproc_t xresults,
		caddr_t resultsp, resultproc_t eachresult);
AUTH *authdes_create(char *servername, uint_t window,
		struct sockaddr_in *syncaddr, des_block *ckey);

/* rpc_td.c */

/* rpcb_clnt.c */
bool_t __rpc_control(int request, void *info);
bool_t rpcb_set(rpcprog_t program, rpcvers_t version,
		const struct netconfig *nconf, const struct netbuf *address);
bool_t rpcb_unset(rpcprog_t program, rpcvers_t version,
		const struct netconfig *nconf);
int rpcb_getaddr(rpcprog_t program, rpcvers_t version,
		const struct netconfig *nconf, struct netbuf *address,
		const char *host);
rpcblist *rpcb_getmaps(const struct netconfig *nconf, const char *host);
enum clnt_stat rpcb_rmtcall(const struct netconfig *nconf, const char *host,
		rpcprog_t prog, rpcvers_t vers, rpcproc_t proc,
		xdrproc_t xdrargs, caddr_t argsp, xdrproc_t xdrres,
		caddr_t resp, struct timeval tout,
		struct netbuf *addr_ptr);
bool_t rpcb_gettime(const char *host, time_t *timep);
char *rpcb_taddr2uaddr(struct netconfig *nconf, struct netbuf *taddr);
struct netbuf *rpcb_uaddr2taddr(struct netconfig *nconf, char *uaddr);

/* rpcb_prot.c */
bool_t xdr_rpcb(XDR *xdrs, RPCB *objp);
bool_t xdr_rpcblist_ptr(XDR *xdrs, rpcblist_ptr *rp);
bool_t xdr_rpcblist(XDR *xdrs, RPCBLIST **rp);
bool_t xdr_rpcb_entry(XDR *xdrs, rpcb_entry *objp);
bool_t xdr_rpcb_entry_list_ptr(XDR *xdrs, rpcb_entry_list_ptr *rp);
bool_t xdr_rpcb_rmtcallargs(XDR *xdrs, struct r_rpcb_rmtcallargs *objp);
bool_t xdr_rpcb_rmtcallres(XDR *xdrs, struct r_rpcb_rmtcallres *objp);
bool_t xdr_netbuf(XDR *xdrs, struct netbuf *objp);

/* rpcb_st_xdr.c */
bool_t xdr_rpcbs_addrlist(XDR *xdrs, rpcbs_addrlist *objp);
bool_t xdr_rpcbs_addrlist(XDR *xdrs, rpcbs_addrlist *objp);

bool_t xdr_rpcbs_rmtcalllist(XDR *xdrs, rpcbs_rmtcalllist *objp);
bool_t xdr_rpcbs_proc(XDR *xdrs, rpcbs_proc objp);
bool_t xdr_rpcbs_addrlist_ptr(XDR *xdrs, rpcbs_addrlist_ptr *objp);
bool_t xdr_rpcbs_rmtcalllist_ptr(XDR *xdrs, rpcbs_rmtcalllist_ptr *objp);
bool_t xdr_rpcb_stat(XDR *xdrs, rpcb_stat *objp);
bool_t xdr_rpcb_stat_byvers(XDR *xdrs, rpcb_stat_byvers objp);

/* rpcdname.c */
int __rpc_get_default_domain(char **domain);

/* rpcsec_gss_if.c */
AUTH *rpc_gss_seccreate(CLIENT *clnt, char *principal, char *mechanism,
		rpc_gss_service_t service_type, char *qop,
		rpc_gss_options_req_t *options_req,
		rpc_gss_options_ret_t *options_ret);
bool_t rpc_gss_set_defaults(AUTH *auth, rpc_gss_service_t service, char *qop);
bool_t rpc_gss_get_principal_name(rpc_gss_principal_t *principal, char
		*mechanism, char *user_name, char *node, char *secdomain);
char **rpc_gss_get_mechanisms(void);
char **rpc_gss_get_mech_info(char *mechanism, rpc_gss_service_t *service);
bool_t rpc_gss_get_versions(u_int *vers_hi, u_int *vers_lo);
bool_t rpc_gss_is_installed(char *mechanism);
bool_t rpc_gss_set_svc_name(char *principal, char *mechanism, uint_t req_time,
		uint_t program, uint_t version);
bool_t rpc_gss_set_callback(rpc_gss_callback_t *cb);
bool_t rpc_gss_getcred(struct svc_req *req, rpc_gss_rawcred_t **rcred,
		rpc_gss_ucred_t **ucred, void **cookie);
bool_t rpc_gss_mech_to_oid(char *mech, rpc_gss_OID *oid);
bool_t rpc_gss_qop_to_num(char *qop, char *mech, u_int *num);
int rpc_gss_max_data_length(AUTH *rpcgss_handle, int max_tp_unit_len);
int rpc_gss_svc_max_data_length(struct svc_req *req, int max_tp_unit_len);
void rpc_gss_get_error(rpc_gss_error_t *error);

/* rtime_tli.c */
int rtime_tli(char *host, struct timeval *timep, struct timeval *timeout);

/* svc.c */
void xprt_register(const SVCXPRT *xprt);
void xprt_unregister(const SVCXPRT *xprt);
bool_t svc_reg(const SVCXPRT *xprt, rpcprog_t prog, rpcvers_t vers,
		void (*dispatch)(), const struct netconfig *nconf);
void svc_unreg(rpcprog_t prog, rpcvers_t vers);
bool_t svc_register(SVCXPRT *xprt, rpcprog_t prog, rpcvers_t vers,
		void (*dispatch)(), int protocol);
void svc_unregister(rpcprog_t prog, rpcvers_t vers);
bool_t svc_sendreply(const SVCXPRT *xprt, xdrproc_t xdr_results,
		caddr_t xdr_location);
void svcerr_noproc(const SVCXPRT *xprt);
void svcerr_decode(const SVCXPRT *xprt);
void svcerr_systemerr(const SVCXPRT *xprt);
void svcerr_auth(const SVCXPRT *xprt, enum auth_stat why);
void svcerr_weakauth(const SVCXPRT *xprt);
void svcerr_noprog(const SVCXPRT *xprt);
void svcerr_progvers(const SVCXPRT *xprt, rpcvers_t low_vers,
		rpcvers_t high_vers);
void svc_getreq(int rdfds);
void svc_getreqset(fd_set *readfds);
void svc_getreq_poll(struct pollfd *pfdp, int pollretval);
void svc_getreq_common(int fd);
SVCXPRT *svc_xprt_alloc(void);
void svc_xprt_free(SVCXPRT *xprt);
bool_t svc_get_local_cred(SVCXPRT *xprt, svc_local_cred_t *lcred);
SVCAUTH *__svc_get_svcauth(SVCXPRT *);
void *__svc_set_proc_cleanup_cb(void *cb);

/* svc_auth.c */
enum auth_stat __authenticate(struct svc_req *rqst, struct rpc_msg *msg);
int svc_auth_reg(int cred_flavor, enum auth_stat (*handler)());

/* svc_auth_sys.c */

/* svc_dg.c */
SVCXPRT *svc_dg_create(int fd, uint_t sendsize, uint_t recvsize);
int svc_dg_enablecache(SVCXPRT *xprt, uint_t size);

/* svc_door.c */
SVCXPRT *svc_door_create(void (*dispatch)(), rpcprog_t prognum,
			rpcvers_t versnum, uint_t sendsize);

/* svc_generic.c */
int svc_create(void (*dispatch)(), rpcprog_t prognum, rpcvers_t versnum,
			const char *nettype);
SVCXPRT *svc_tp_create(void (*dispatch)(), rpcprog_t prognum, rpcvers_t versnum,
			const struct netconfig *nconf);
SVCXPRT *svc_tli_create(int fd, const struct netconfig *nconf,
			const struct t_bind *bindaddr, uint_t sendsz,
			uint_t recvsz);

/* svc_raw.c */
SVCXPRT *svc_raw_create(void);

/* svc_run.c */
void svc_run(void);
void svc_exit(void);
void svc_done(SVCXPRT *xprt);
bool_t rpc_control(int op, void *info);

/* svc_simple.c */
int rpc_reg(rpcprog_t prognum, rpcvers_t versnum, rpcproc_t procnum,
		char *(*progname)(), xdrproc_t inproc, xdrproc_t outproc,
		const char *nettype);

/* svc_vc.c */
SVCXPRT *svc_vc_create(int fd, uint_t sendsize, uint_t recvsize);
SVCXPRT *svc_fd_create(int fd, uint_t sendsize, uint_t recvsize);
bool_t __svc_vc_dupcache_init(SVCXPRT *xprt, void *condition, int basis);
int __svc_vc_dup(struct svc_req *req, caddr_t *resp_buf, uint_t *resp_bufsz);
int __svc_vc_dupdone(struct svc_req *req, caddr_t resp_buf, uint_t resp_bufsz,
				int status);

/* svcauth_des.c */
int authdes_getucred(const struct authdes_cred *adc, uid_t *uid, gid_t *gid,
				short *grouplen, gid_t *groups);
enum auth_stat __svcauth_des(struct svc_req *rqst, struct rpc_msg *msg);

/* ti_opts.c */
int __rpc_negotiate_uid(int fd);
int __rpc_get_local_uid(SVCXPRT *trans, uid_t *uid_out);

/* xdr.c */
void xdr_free(xdrproc_t proc, char *objp);
bool_t xdr_void(void);
bool_t xdr_int(XDR *xdrs, int *ip);
bool_t xdr_u_int(XDR *xdrs, uint_t *up);
bool_t xdr_long(XDR *xdrs, long *lp);
bool_t xdr_u_long(XDR *xdrs, ulong_t *ulp);
bool_t xdr_short(XDR *xdrs, short *sp);
bool_t xdr_u_short(XDR *xdrs, ushort_t *sp);
bool_t xdr_char(XDR *xdrs, char *cp);
bool_t xdr_u_char(XDR *xdrs, uchar_t *cp);
bool_t xdr_bool(XDR *xdrs, bool_t *bp);
bool_t xdr_enum(XDR *xdrs, enum_t *ep);
bool_t xdr_opaque(XDR *xdrs, caddr_t cp, uint_t cnt);
bool_t xdr_bytes(XDR *xdrs, char **cpp, uint_t *sizep, uint_t maxsize);
bool_t xdr_netobj(XDR *xdrs, struct netobj *np);
bool_t xdr_union(XDR *xdrs, enum_t *dscmp, char *unp,
			const struct xdr_discrim *choices, xdrproc_t dfault);
bool_t xdr_string(XDR *xdrs, char **cpp, uint_t maxsize);
bool_t xdr_hyper(XDR *xdrs, longlong_t *hp);
bool_t xdr_u_hyper(XDR *xdrs, u_longlong_t *hp);
bool_t xdr_longlong_t(XDR *xdrs, longlong_t *hp);
bool_t xdr_u_longlong_t(XDR *xdrs, u_longlong_t *hp);
bool_t xdr_ulonglong_t(XDR *xdrs, u_longlong_t *hp);
bool_t xdr_wrapstring(XDR *xdrs, char **cpp);

/* xdr_array.c */
bool_t xdr_array(XDR *xdrs, caddr_t *addrp, uint_t *sizep, uint_t maxsize,
				uint_t elsize, xdrproc_t elproc);
bool_t xdr_vector(XDR *xdrs, char *basep, uint_t nelem, uint_t elemsize,
				xdrproc_t xdr_elem);

/* xdr_float.c */
bool_t xdr_float(XDR *xdrs, float *fp);
bool_t xdr_double(XDR *xdrs, double *dp);
bool_t xdr_quadruple(XDR *xdrs, long double *fp);

/* xdr_mem.c */
void xdrmem_create(XDR *xdrs, caddr_t addr, uint_t size, enum xdr_op op);

/* xdr_rec.c */
void xdrrec_create(XDR *xdrs, uint_t sendsize, uint_t recvsize,
			caddr_t tcp_handle, int (*readit)(), int (*writeit)());

uint_t xdrrec_readbytes(XDR *xdrs, caddr_t addr, uint_t l);
bool_t xdrrec_skiprecord(XDR *xdrs);
bool_t xdrrec_eof(XDR *xdrs);
bool_t xdrrec_endofrecord(XDR *xdrs, bool_t sendnow);

/* xdr_refer.c */
bool_t xdr_reference(XDR *xdrs, caddr_t *pp, uint_t size, xdrproc_t proc);
bool_t xdr_pointer(XDR *xdrs, char **objpp, uint_t obj_size, xdrproc_t xdr_obj);

/* xdr_sizeof.c */
unsigned int xdr_sizeof(xdrproc_t func, void *data);

/* xdr_stdio.c */
void xdrstdio_create(XDR *xdrs, FILE *file, enum xdr_op op);

/* svid_funcs.c */
#undef	auth_destroy
#undef	clnt_call
#undef	clnt_control
#undef	clnt_destroy
#undef	clnt_freeres
#undef	clnt_geterr
#undef	svc_destroy
#undef	svc_freeargs
#undef	svc_getargs
#undef	svc_getrpccaller
#undef	xdr_destroy
#undef	xdr_getpos
#undef	xdr_inline
#undef	xdr_setpos
void auth_destroy(AUTH *auth);
enum clnt_stat clnt_call(CLIENT *cl, rpcproc_t proc, xdrproc_t xargs,
			caddr_t argsp, xdrproc_t xres, caddr_t resp,
			struct timeval timeout);
bool_t clnt_control(CLIENT *cl, uint_t rq, void *in);
void clnt_destroy(CLIENT *cl);
bool_t clnt_freeres(CLIENT *cl, xdrproc_t xres, caddr_t resp);
void clnt_geterr(CLIENT *cl, struct rpc_err *errp);
bool_t svc_control(SVCXPRT *xprt, const uint_t rq, void *in);
bool_t svc_freeargs(SVCXPRT *xprt, xdrproc_t xargs, char *argsp);
bool_t svc_getargs(SVCXPRT *xprt, xdrproc_t xargs, char *argsp);
struct netbuf *svc_getrpccaller(SVCXPRT *xprt);
long *xdr_inline(XDR *xdrs, int len);
void xdr_destroy(XDR *xdrs);
uint_t xdr_getpos(XDR *xdrs);
bool_t xdr_setpos(XDR *xdrs, uint_t pos);

/*
 * usr/src/lib/libnsl/saf routines
 */

/* checkver.c */
int check_version(int ver, char *fname);

/* doconfig.c */
int doconfig(int fd, char *script, long rflag);

/*
 * usr/src/lib/libnsl/yp routines
 */

/* dbm.c */
int dbminit(char *file);
int dbmclose(void);
datum fetch(datum key);
int delete(datum key);
int store(datum key, datum dat);
datum firstkey(void);
datum nextkey(datum key);
datum firsthash(long hash);
datum makdatum(char *buf, int n);
long hashinc(long hash);
long calchash(datum item);

/* yp_all.c */
int yp_all(char *domain, char *map, struct ypall_callback *callback);
int __yp_all_rsvdport(char *domain, char *map, struct ypall_callback *callback);

/* yp_b_clnt.c */
enum ypbind_resptype {
	YPBIND_SUCC_VAL = 1,
	YPBIND_FAIL_VAL = 2
};
typedef enum ypbind_resptype ypbind_resptype;
struct ypbind_resp {
	ypbind_resptype ypbind_status;
	union {
		uint_t ypbind_error;
		struct ypbind_binding *ypbind_bindinfo;
	} ypbind_resp_u;
};
typedef struct ypbind_resp ypbind_resp;
struct ypbind_domain {
	char *ypbind_domainname;
	rpcvers_t ypbind_vers;
};
typedef struct ypbind_domain ypbind_domain;
struct ypbind_setdom {
	char *ypsetdom_domain;
	struct ypbind_binding *ypsetdom_bindinfo;
};
typedef struct ypbind_setdom ypbind_setdom;
ypbind_resp *ypbindproc_domain_3(ypbind_domain *argp, CLIENT *clnt);

/* yp_b_xdr.c */
bool_t xdr_ypbind_domain(XDR *xdrs, ypbind_domain *objp);
bool_t xdr_ypbind_resp(XDR *xdrs, ypbind_resp *objp);
bool_t xdr_ypbind_setdom(XDR *xdrs, ypbind_setdom *objp);
bool_t xdr_ypbind_resptype(XDR *xdrs, ypbind_resptype *objp);

/* yp_bind.c */
struct dom_binding {
	struct dom_binding *dom_pnext;
	char *dom_domain;
	struct ypbind_binding *dom_binding;
	CLIENT *dom_client;
	int cache_bad;
	int fd;
	dev_t rdev;
	int ref_count;
	int need_free;
	mutex_t server_name_lock;
};
int __yp_dobind(char *domain, struct dom_binding **binding);
int __yp_rel_binding(struct dom_binding *binding);
void yp_unbind(char *domain);
int __yp_add_binding(char *domain, char *addr);
int yp_bind(char *domain);
int yp_get_default_domain(char **domain);
int usingypmap(char **ddn, char *map);
CLIENT *__clnt_create_loopback(rpcprog_t prog, rpcvers_t vers, int err);

/* yp_enum.c */
int yp_first(char *domain, char *map, char **key, int *keylen,
					char **val, int  *vallen);
int yp_next(char *domain, char *map, char *inkey, int inkeylen,
		char **outkey, int  *outkeylen, char **val, int *vallen);

/* yp_master.c */
int yp_master(char *domain, char *map, char **master);
int __yp_master_rsvdport(char *domain, char *map, char **master);

/* yp_match.c */
int yp_match(char *domain, char *map, char *key, int keylen,
						char **val, int  *vallen);
int yp_match_rsvdport(char *domain, char *map, char *key, int keylen,
						char **val, int  *vallen);
void __empty_yp_cache(void);

/* yp_order.c */
int yp_order(char *domain, char *map, unsigned long *order);

/* yp_rsvd.c */
CLIENT *__yp_clnt_create_rsvdport(const char *hostname,
			rpcprog_t prog, rpcvers_t vers,
			const char *nettype,
			const uint_t sendsz, const uint_t recvsz);

/* yp_update.c */
int yp_update(char *domain, char *map, unsigned op,
			char *key, int keylen, char *data, int datalen);

/* yp_xdr.c */
bool xdr_datum(XDR * xdrs, datum *pdatum);
bool xdr_ypdomain_wrap_string(XDR *xdrs, char **ppstring);
bool xdr_ypmap_wrap_string(XDR *xdrs, char **ppstring);
bool xdr_ypreq_key(XDR *xdrs, struct ypreq_key *ps);
bool xdr_ypreq_nokey(XDR *xdrs, struct ypreq_nokey *ps);
bool xdr_ypresp_val(XDR *xdrs, struct ypresp_val *ps);
bool xdr_ypresp_key_val(XDR *xdrs, struct ypresp_key_val *ps);
bool xdr_ypowner_wrap_string(XDR *xdrs, char **ppstring);
bool xdr_ypmap_parms(XDR *xdrs, struct ypmap_parms *ps);
bool xdr_ypresp_master(XDR *xdrs, struct ypresp_master *ps);
bool xdr_ypresp_order(XDR * xdrs, struct ypresp_order *ps);
bool xdr_ypresp_maplist(XDR *xdrs, struct ypresp_maplist *ps);
bool xdr_yppushresp_xfr(XDR *xdrs, struct yppushresp_xfr *ps);
bool xdr_ypreq_newxfr(XDR *xdrs, struct ypreq_newxfr *ps);
bool xdr_ypreq_xfr(XDR *xdrs, struct ypreq_xfr *ps);
bool xdr_ypall(XDR *xdrs, struct ypall_callback *callback);

/* yperr_string.c */
char *yperr_string(int code);

/* yppasswd_xdr.c */
bool_t xdr_yppasswd(XDR *xdrsp, struct yppasswd *pp);

/* ypprot_err.c */
int ypprot_err(int yp_protocol_error);

/* ypupd.c */
bool_t xdr_yp_buf(XDR *xdrs, yp_buf *objp);
bool_t xdr_ypupdate_args(XDR *xdrs, ypupdate_args *objp);
bool_t xdr_ypdelete_args(XDR *xdrs, ypdelete_args *objp);

/* nis_sec_mechs.c */
char *__nis_keyalg2authtype(keylen_t keylen, algtype_t algtype,
	char *authtype, size_t authtype_len);

/* usr/src/lib/libnsl/nss/parse.c */
char *_strtok_escape(char *string, char *sepset, char **lasts);
