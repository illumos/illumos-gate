
/* : : generated by proto : : */
/***********************************************************************
*                                                                      *
*               This software is part of the ast package               *
*          Copyright (c) 1982-2008 AT&T Intellectual Property          *
*                      and is licensed under the                       *
*                  Common Public License, Version 1.0                  *
*                    by AT&T Intellectual Property                     *
*                                                                      *
*                A copy of the License is available at                 *
*            http://www.opensource.org/licenses/cpl1.0.txt             *
*         (with md5 checksum 059e8cd6165cb4c31e351f2b69388fd9)         *
*                                                                      *
*              Information and Software Systems Research               *
*                            AT&T Research                             *
*                           Florham Park NJ                            *
*                                                                      *
*                  David Korn <dgk@research.att.com>                   *
*                                                                      *
***********************************************************************/
                  
#ifndef SH_INTERACTIVE
#if !defined(__PROTO__)
#include <prototyped.h>
#endif
#if !defined(__LINKAGE__)
#define __LINKAGE__		/* 2004-08-11 transition */
#endif

/*
 * David Korn
 * AT&T Labs
 *
 * Interface definitions for shell command language
 *
 */

#include	<ast.h>
#include	<cdt.h>
#ifdef _SH_PRIVATE
#   include	"name.h"
#else
#   include	<nval.h>
#endif /* _SH_PRIVATE */

#define SH_VERSION	20071012

#undef NOT_USED
#define NOT_USED(x)	(&x,1)

/* options */
typedef struct
{
	unsigned long v[4];
}
Shopt_t;

typedef struct Shell_s Shell_t;

typedef void	(*Shinit_f) __PROTO__((Shell_t*, int));
typedef int	(*Shwait_f) __PROTO__((int, long, int));

union Shnode_u;
typedef union Shnode_u Shnode_t;

#define SH_CFLAG	0
#define SH_HISTORY	1	/* used also as a state */
#define	SH_ERREXIT	2	/* used also as a state */
#define	SH_VERBOSE	3	/* used also as a state */
#define SH_MONITOR	4	/* used also as a state */
#define	SH_INTERACTIVE	5	/* used also as a state */
#define	SH_RESTRICTED	6
#define	SH_XTRACE	7
#define	SH_KEYWORD	8
#define SH_NOUNSET	9
#define SH_NOGLOB	10
#define SH_ALLEXPORT	11
#define SH_PFSH		12
#define SH_IGNOREEOF	13
#define SH_NOCLOBBER	14
#define SH_MARKDIRS	15
#define SH_BGNICE	16
#define SH_VI		17
#define SH_VIRAW	18
#define	SH_TFLAG	19
#define SH_TRACKALL	20
#define	SH_SFLAG	21
#define	SH_NOEXEC	22
#define SH_GMACS	24
#define SH_EMACS	25
#define SH_PRIVILEGED	26
#define SH_SUBSHARE	27	/* subshell shares state with parent */
#define SH_NOLOG	28
#define SH_NOTIFY	29
#define SH_DICTIONARY	30
#define SH_PIPEFAIL	32
#define SH_GLOBSTARS	33
#define SH_XARGS	34
#define SH_RC		35
#define SH_SHOWME	36

/*
 * passed as flags to builtins in Nambltin_t struct when BLT_OPTIM is on
 */
#define SH_BEGIN_OPTIM	0x1
#define SH_END_OPTIM	0x2

/* The following type is used for error messages */

/* error messages */
extern __MANGLE__ const char	e_defpath[];
extern __MANGLE__ const char	e_found[];
extern __MANGLE__ const char	e_nospace[];
extern __MANGLE__ const char	e_format[];
extern __MANGLE__ const char 	e_number[];
extern __MANGLE__ const char	e_restricted[];
extern __MANGLE__ const char	e_recursive[];
extern __MANGLE__ char		e_version[];

typedef struct sh_scope
{
	struct sh_scope	*par_scope;
	int		argc;
	char		**argv;
	char		*cmdname;
	char		*filename;
	char		*funname;
	int		lineno;
	Dt_t		*var_tree;
	struct sh_scope	*self;
} Shscope_t;

/*
 * Saves the state of the shell
 */

struct Shell_s
{
	Shopt_t		options;	/* set -o options */
	Dt_t		*var_tree;	/* for shell variables */
	Dt_t		*fun_tree;	/* for shell functions */
	Dt_t		*alias_tree;	/* for alias names */
	Dt_t		*bltin_tree;    /* for builtin commands */
	Shscope_t	*topscope;	/* pointer to top-level scope */
	int		inlineno;	/* line number of current input file */
	int		exitval;	/* most recent exit value */
	unsigned char	trapnote;	/* set when trap/signal is pending */
	char		subshell;	/* set for virtual subshell */
	char		shcomp;		/* set when runing shcomp */
#ifdef _SH_PRIVATE
	_SH_PRIVATE
#endif /* _SH_PRIVATE */
};

/* flags for sh_parse */
#define SH_NL		1	/* Treat new-lines as ; */
#define SH_EOF		2	/* EOF causes syntax error */

/* symbolic values for sh_iogetiop */
#define SH_IOCOPROCESS	(-2)
#define SH_IOHISTFILE	(-3)

#include	<cmd.h>

/* symbolic value for sh_fdnotify */
#define SH_FDCLOSE	(-1)

#undef getenv			/* -lshell provides its own */

#if defined(__EXPORT__) && defined(_DLL)
#   ifdef _BLD_shell
#undef __MANGLE__
#define __MANGLE__ __LINKAGE__ __EXPORT__
#   endif /* _BLD_shell */
#endif /* _DLL */

extern __MANGLE__ Dt_t		*sh_bltin_tree __PROTO__((void));
extern __MANGLE__ void		sh_subfork __PROTO__((void));
extern __MANGLE__ Shell_t		*sh_init __PROTO__((int,char*[],Shinit_f));
extern __MANGLE__ int		sh_reinit __PROTO__((char*[]));
extern __MANGLE__ int 		sh_eval __PROTO__((Sfio_t*,int));
extern __MANGLE__ void 		sh_delay __PROTO__((double));
extern __MANGLE__ __V_		*sh_parse __PROTO__((Shell_t*, Sfio_t*,int));
extern __MANGLE__ int 		sh_trap __PROTO__((const char*,int));
extern __MANGLE__ int 		sh_fun __PROTO__((Namval_t*,Namval_t*, char*[]));
extern __MANGLE__ int 		sh_funscope __PROTO__((int,char*[],int(*)(__V_*),__V_*,int));
extern __MANGLE__ Sfio_t		*sh_iogetiop __PROTO__((int,int));
extern __MANGLE__ int		sh_main __PROTO__((int, char*[], Shinit_f));
extern __MANGLE__ int		sh_run __PROTO__((int, char*[]));
extern __MANGLE__ void		sh_menu __PROTO__((Sfio_t*, int, char*[]));
extern __MANGLE__ Namval_t		*sh_addbuiltin __PROTO__((const char*, int(*)(int, char*[],__V_*), __V_*));
extern __MANGLE__ char		*sh_fmtq __PROTO__((const char*));
extern __MANGLE__ char		*sh_fmtqf __PROTO__((const char*, int, int));
extern __MANGLE__ Sfdouble_t	sh_strnum __PROTO__((const char*, char**, int));
extern __MANGLE__ int		sh_access __PROTO__((const char*,int));
extern __MANGLE__ int 		sh_close __PROTO__((int));
extern __MANGLE__ int 		sh_dup __PROTO__((int));
extern __MANGLE__ void 		sh_exit __PROTO__((int));
extern __MANGLE__ int		sh_fcntl __PROTO__((int, int, ...));
extern __MANGLE__ Sfio_t		*sh_fd2sfio __PROTO__((int));
extern __MANGLE__ int		(*sh_fdnotify __PROTO__((int(*)(int,int)))) __PROTO__((int,int));
extern __MANGLE__ Shell_t		*sh_getinterp __PROTO__((void));
extern __MANGLE__ int		sh_open __PROTO__((const char*, int, ...));
extern __MANGLE__ int		sh_openmax __PROTO__((void));
extern __MANGLE__ Sfio_t		*sh_pathopen __PROTO__((const char*));
extern __MANGLE__ ssize_t 		sh_read __PROTO__((int, __V_*, size_t));
extern __MANGLE__ ssize_t 		sh_write __PROTO__((int, const __V_*, size_t));
extern __MANGLE__ off_t		sh_seek __PROTO__((int, off_t, int));
extern __MANGLE__ int 		sh_pipe __PROTO__((int[]));
extern __MANGLE__ mode_t 		sh_umask __PROTO__((mode_t));
extern __MANGLE__ __V_		*sh_waitnotify __PROTO__((Shwait_f));
extern __MANGLE__ Shscope_t	*sh_getscope __PROTO__((int,int));
extern __MANGLE__ Shscope_t	*sh_setscope __PROTO__((Shscope_t*));
extern __MANGLE__ void		sh_sigcheck __PROTO__((void));
extern __MANGLE__ unsigned long	sh_isoption __PROTO__((int));
extern __MANGLE__ unsigned long	sh_onoption __PROTO__((int));
extern __MANGLE__ unsigned long	sh_offoption __PROTO__((int));
extern __MANGLE__ int 		sh_waitsafe __PROTO__((void));
extern __MANGLE__ int		sh_exec __PROTO__((const Shnode_t*,int));

#if SHOPT_DYNAMIC
    extern __MANGLE__ __V_		**sh_getliblist __PROTO__((void));
#endif /* SHOPT_DYNAMIC */

/*
 * direct access to sh is obsolete, use sh_getinterp() instead
 */
#if !defined(_SH_PRIVATE) && defined(__IMPORT__) && !defined(_BLD_shell)
	extern __MANGLE__ __IMPORT__  Shell_t sh;
#else
	extern __MANGLE__ Shell_t sh;
#endif

#ifdef _DLL
#undef __MANGLE__
#define __MANGLE__ __LINKAGE__
#endif /* _DLL */

#ifndef _SH_PRIVATE
#   define access(a,b)	sh_access(a,b)
#   define close(a)	sh_close(a)
#   define exit(a)	sh_exit(a)
#   define fcntl(a,b,c)	sh_fcntl(a,b,c)
#   define pipe(a)	sh_pipe(a)
#   define read(a,b,c)	sh_read(a,b,c)
#   define write(a,b,c)	sh_write(a,b,c)
#   define umask(a)	sh_umask(a)
#   define dup		sh_dup
#   if _lib_lseek64
#	define open64	sh_open
#	define lseek64	sh_seek
#   else
#	define open	sh_open
#	define lseek	sh_seek
#   endif
#endif /* !_SH_PRIVATE */

#define SH_SIGSET	4
#define SH_EXITSIG	0400	/* signal exit bit */
#define SH_EXITMASK	(SH_EXITSIG-1)	/* normal exit status bits */
#define SH_RUNPROG	-1022	/* needs to be negative and < 256 */

#endif /* SH_INTERACTIVE */
