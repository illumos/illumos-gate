.fp 5 CW
.de Af
.ds ;G \\*(;G\\f\\$1\\$3\\f\\$2
.if !\\$4 .Af \\$2 \\$1 "\\$4" "\\$5" "\\$6" "\\$7" "\\$8" "\\$9"
..
.de aF
.ie \\$3 .ft \\$1
.el \{\
.ds ;G \&
.nr ;G \\n(.f
.Af "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7" "\\$8" "\\$9"
\\*(;G
.ft \\n(;G \}
..
.de L
.aF 5 \\n(.f "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7"
..
.de LR
.aF 5 1 "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7"
..
.de RL
.aF 1 5 "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7"
..
.de EX		\" start example
.ta 1i 2i 3i 4i 5i 6i
.PP
.RS 
.PD 0
.ft 5
.nf
..
.de EE		\" end example
.fi
.ft
.PD
.RE
.PP
..
.TH COMPATIBILITY 3
.SH NAME
compatibility \- ast library compatibility routines
.SH SYNOPSIS
.EX
#include <ast.h>

int	atexit(void(*)(void));
char*	confstr(int);
int	dup2(int, int);
long	fpathconf(int, int);
int	getgroups(int, int*);
char*	getwd(char*);
int	killpg(int, int);
int	link(const char*, const char*);
int	lstat(const char*, struct stat*);
int	memcmp(const char*, const char*, unsigned int);
char*	memcpy(char*, const char*, int);
char*	memset(char*, char, int);
int	mkdir(const char*, mode_t);
int	mkfifo(const char*, mode_t);
int	mknod(const char*, mode_t);
char*	mktemp(char*);
int	mount(const char*, const char*, int);
long	pathconf(const char*, int);
int	perror(const char*);
FILE*	popen(const char*, const char*);
int	readlink(const char*, char*, int);
int	remove(const char*);
int	rename(const char*, const char*);
int	rmdir(const char*);
int	setpgid(pid_t, pid_t);
int	sigmask(int);
int	sigsetmask(long);
int	sigunblock(int);
char*	strchr(const char*, int);
char*	strrchr(const char*, int);
double	strtod(const char*, char**);
long	strtol(const char*, char**, int);
int	symlink(const char*, const char*);
long	sysconf(int);
int	system(const char*);
char*	tmpnam(char*);
int	unlink(const char*);
int	vfork(void);
int	waitpid(pid_t, int*, int);
.EE
.SH DESCRIPTION
These routines are described in the ANSI C, POSIX, BSD and System V manual
sections 2 and 3.
The interfaces are preserved and present in all libast implementations.
Where conflicts exist the POSIX syntax and semantics are implied.
The appropriate error value is returned and
.I errno
is set to
.L EINVAL
when emulation is either too expensive or not possible.
.SH CAVEATS
If you
.L "#undef foo"
and then call
.L foo
you may end up with the local implementation of
.LR foo ,
and then you get what you payed for.
